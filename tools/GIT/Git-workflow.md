# Git — WorkFlow

[TOC]

## Делаем fork-repository из master-repository (htmlacademy)

## Клонируем fork-repo на локальный комп

* устанавливаем связь с удаленным репозиторием
  
```bash
git remote add academy git@github.com:htmlacademy-javascript/219593-code-and-magick-20.git
```

```bash
git remote add academy git@github.com:htmlacademy-javascript/219593-kekstagram-20.git
```

 Привязку к origin можно не делать - это делается автоматически при клонировании!!!

* смотрим сколько удаленных репозиториев есть `git remote -v`

1. В вашей локальной копии переключитесь в ветку master `git checkout master`
2. Заберите изменения из репозитория Академии academy `git pull academy master`
git pull является по существу командой git fetch,
непосредственно за которой следует команда git merge!
3. Отправьте изменения ветки master в ваш форк на github (или origin)
`git push`
`git push origin master`
`git push [имя удаленного репозитория] [ветка]`
4. Когда вы обновили master, создайте ветку для выполнения задания
`git checkout -b module4-task1`
5. ПОСЛЕ Выполнения задания
`git add .`
`git commit`
6. `git push origin module7-task2`
    * kekstagram-20 `git checkout -b module3-task2`

Лучше делать pull request из репозитория на github

`git push --set-upstream origin module1-task1`

команда
`git push --set-upstream origin <new-branch>`
 затягивает вашу новую ветку в ваш форк, и сразу выдаст ссылку на страницу GitHub для создания pull-request.

Это позволит нам в будущем не указывать дополнительные параметры:
локальная ветка будет автоматически связана с удаленной веткой,
и вы можете использовать git push без каких-либо аргументов.

Можно записывать как
`git push -u origin module1-task2`

* флаг -u представляет краткой обозначение для --set-upstream,
который устанавливает конфигурацию ветки

## Дополнительная информация

### Получаем инфо. об удаленном репозитории `git remote show`

Команда git remote show [имя удал. реп.]
позволяет просмотреть дополнительную информацию о конкретном удал. реп., включая удаленные ветки, локальные ветки, а также настройки для git pull и git push.

### Новая команда `git switch`

  git switch берет на себя часть функционала git checkout, связанную с переключением веток.
  Например:
  `git switch mybranch1` — переключиться на ветку mybranch1
  `git switch -c mybranch2` — создать новую ветку и переключиться на нее.

### Новая команда `git restore`

git restore служит для восстановления файлов.
Команда позволяет восстанавливать файлы, но при этом четко показывает откуда и куда будут применяться изменения.

Пример использования команды git restore

```bash
git restore --source HEAD~3 --staged --worktree main.c
```

---

### Настройка .gitignore

* Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
* Внутри файла перечислите названия файлов / папок, которые нужно игнорировать, каждый с новой строки.

  Примеры файлов, которые нужно игнорировать:
  * Логи
  * Артефакты систем сборки
  * Папки node_modules в проектах node.js
  * Папки, созданные IDE, например, Netbeans или Intellij
  * Разнообразные заметки разработчика.

```json
*.log
build/
node_modules/
.idea/
my_notes.txt
```

Символ слэша в конце некоторых линий означает директорию
(и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.

---

## Cache

### Удалить из кэша

`git rm --cached`

## Merging

`git log --merge -p <name of file>`
Это показывает все коммиты, которые касались этого файла между общим предком и двумя головами, которые вы объединяете.
(Таким образом, он не включает в себя коммиты, которые уже существуют в обеих ветвях до слияния.)
Это помогает игнорировать различия, которые явно не являются фактором в вашем текущем конфликте.

## Привязка к удаленной ветке

`git checkout -b new_server-dev-master origin/new_server-dev-master`
