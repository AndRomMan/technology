# Git — commands

[TOC]

---

## Терминология Git

- index — область зафиксированных изменений, т.е. всё то, что вы подготовили к сохранению в репозиторий.
- commit — изменения, отправленные в репозиторий.
- HEAD — указатель на commit, в котором мы находимся
- master — имя ветки по-умолчанию, это тоже указатель на определённый коммит
- origin — имя удалённого репозитория по умолчанию (можно дать другое)
- checkout — взять из репозитория какое-либо его состояние
- Untracked file - не отслеживаемый файл; git видит файл, но он отсутствует в предыдущем снимке состояний (коммит); подобный подход гарантирует, что в репозитории не окажется случайных файлов. Такие файла необходимо добавить в индекс командой git add.
- Changes to be committed - все проиндексированные файл идут под этим заголовком.
- Changes not staged for commit - отслеживаемый файл изменен, но пока не проиндексирован.
- Changes but not updated - после удаления файла; измененные, но не проиндексированные
- fast forward (перемотка) - возникает при слиянии веток, указывает на то, что изменений требующих объединений нет; другими словами объединяется ветка-родитель и ветка-потомок
- unmerged (необъединенное) - обычно возникает при конфликтах
- pull request - запрос на включение.
- fork - создать свою копию чужого репозитория на севере GitHub.
- clone - если клонировать форк на локальную систему, то локальный репозиторий будет
  отслеживать удалённый форк как **origin**,
  а оригинальный репозиторий как **upstream**.

---

### Вывести краткую подсказку для команды

- (например config):
  `git config -h (ключ -h)`

### Вывести расширенную подсказку

- `git help config`
  В браузере откроется страница с расширенным описанием команды.

---

## 1 Создаем git репозиторий

### в корне рабочего проекта

- `$ cd h/mega/project/git-lessons`
- `$ git init`

---

## 2 Устанавливаем настройки пользователя

Здесь настройки задаются глобально, поэтому они будут одинаковы для
всех репозиториев. Это важно для настроек доступа пользователя.

- git config

  - `git config --global user.name "Your Name"`
  - `git config --global user.email "your_email@whatever.com"`

- Глобальный уровень конфигурации:
  `c:/Users/username/.gitconfig`

- Локальный уровень конфигурации (ключ --local):
  `H:\mega\project\git-lessons\.git\config`

- Системный уровень конфигурации (ключ --system):
  `C:\Git\etc\config`

git ищет необходимые данные в таком порядке:
`local -> global -> system`

---

```json
global .gitconfig
[user]
name = AndRomMan
email = demromdeveloper@gmail.com
```

---

Считаем конфигурацию: `git config --list` (команда выводит параметры из ВСЕХ config)
Или откроем конфигурационные файлы. В них мы можем прописать необходимые настройки.

Для контроля только global config: `git config --list --global`

---

### Настройка редактора для git

Примеры конфигураций для разных редакторов
<https://git-scm.com/book/ru/v2/Appendix-C%3A-%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-Git-%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F#r_core_editor>

---

### Параметры установки окончаний строк

При настройке autocrlf = true корректировка CRLF в LF происходит только в 1 сторону.
Это удобно для unix систем и если редактор настроен на LF

### правильная конфигурация

```bush
[core]
  autocrlf = input
  safecrlf = warn
  quotepath = off
  editor = 'C:/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin
  editor = 'C:/TCPU72/Programm/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin
```

### Как работает autocrlf

1. true: x -> LF -> CRLF
2. input: x -> LF -> LF
3. false: x -> x -> x

Выполнить команды или прописать в конфиге:

```bush
git config --global core.autocrlf input
git config --global core.safecrlf warn
```

---

## 3 Конфигурировать файл .gitattributes и gitignore

### и положить их в корень проекта

Минимально необходимая конфигурация .gitattributes:

```bush
 text eol=lf
 .png binary
 .jpg binary
 .jpeg binary
 .webp binary
 .woff binary
 .woff2 binary
```

Конфигурировать файл .gitignore - проверить какие папки игнорируются, а какие нет

Перейдите в папку, где лежит файл .gitignore (или любую другую папку в репозитории)
и выполните команду
`git check-ignore -v *`

Можно выводить и папки/файлы, к которым правила игнорирования не применяются:
`git check-ignore -vn *`

`git check-ignore -v /конкретный/путь`

---

## 4 Установка отображения unicode

По умолчанию, git будет печатать не-ASCII символов в именах файлов в виде восьмеричных последовательностей \nnn.
Что бы избежать нечитаемых строк, установите соответствующий флаг.

git config --global core.quotepath off

---

## 5 Проверка настроек

- Вывод списка всех установленных настроек:
  `git config --list`

- Вывод on-line справки:
  `git log --help`

- Информация о текущем состоянии репозитория: актуальна ли информация, что нового, что поменялось
  `git status`

---

## 6 Настроить SSH для работы с удаленным репозиторием

### [см. файл настроек getSSH.md](getSSH.md)

---

## 7 Создать репозиторий на github

Синхронизировать локальный и удаленный репозитории.
Команды для этого выдает github в новом github репозитории!

В своем локальном репозитории выполните команду:

`git remote add origin https://github.com/username/myproject.git`
`git remote add origin git@github.com:AndRomMan/vue3.git`

Данная команда добавит удаленный репозиторий с именем origin, который указывает на ваш Github-репозиторий.

Получаем инфо. об удаленном репозитории `git remote show`

Теперь можно выполнить команду `git push`, чтобы отправить все ваши изменения на удаленный репозиторий:

`git push -u origin master`

Можно записывать как
`git push -u origin module1-task2`

флаг -u представляет краткой обозначение для --set-upstream,
который устанавливает конфигурацию ветки

---

## Репозитории

Информация об удаленных репозиториях:

`git remote -v`          # показать алиасы и URL удаленных репозиториев
`git remote show origin` # детальная инфа об удаленном репозитории

Добавление и удаление удаленных репозиториев:

`git remote add <alias> <URL>`
`git remote rm origin`

Пример

`git remote add origin git@github.com:vendor/repo-name.git`

Изменить url удаленного репозитория при ошибке:

```bash
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.
Please make sure you have the correct access rights and the repository exists.
```

`git remote set-url origin git@github.com:vendor/repo.git`
`git remote set-url origin git://github.com/vendor/repo.git`

## 8 Получение списка произведенных изменений —

результатом будет список всех коммитов в репозиторий, которые мы успели совершить

`$ git log`

### Краткая запись

```bush
git log --pretty=oneline
git log -n
```

здесь n - количество последних коммитов, которые будут выведены!

```bush
git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<your name>
git log --pretty=oneline --all
git log --pretty=format:'%h - %an, %ar : %s'
git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
git log --pretty=format:'%h - %ar : %s' --graph --date=short

logs = log --pretty=format:'%C(yellow)%h%Creset|%Cgreen%ad%Creset|%C(blue)%d%Creset|%s' --date=short --graph
logf = log --pretty=format:'%C(yellow)%H%Creset|%Cgreen%ad%Creset|%s|%Cred%an%Creset'
logh = log --oneline --graph
```

```bush
    --pretty="..." — определяет формат вывода.
    --graph — отображает дерево коммитов в виде ASCII-графика
    --date=short — сохраняет формат даты коротким и симпатичным
    --stat используется для получения краткой статистики по каждому коммиту
```

````bush
    --author=alex, если я хочу увидеть только изменения,
    которые сделал я за последние 7 дней
    ```git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'```
````

---

### Sets

- '%C(yellow)%set%Creset - изменение цвета
- %d reference pointer(branch, tag) names
- %H Хеш коммита
- %h Сокращённый хеш коммита
- %T Хеш дерева
- %t Сокращённый хеш дерева
- %P Хеши родительских коммитов
- %p Сокращённые хеши родительских коммитов
- %an Имя автора
- %ae Электронная почта автора
- %ad Дата коммита (формат соответствует параметру --date=)
- %ar Дата автора, относительная (пр. "2 мес. назад")
- %cn Имя коммитера
- %ce Электронная почта коммитера
- %cd Дата коммитера
- %cr Дата коммитера, относительная
- %s Комментарий

- `-p` показывает изменения в каждом коммите
- `--stat` показывает сокращённую статистику для коммитов,
  например изменённые файлы и количество
  добавленных/удалённых строк в каждом их них
- `-n` показывает **n** последних коммитов;
- `--since=___`и `--until=___` позволяет отфильтровать коммиты
  по промежутку времени,
  например:

  - `--since="2019-01-01"` покажет коммиты с 1 января 2019 года;

- `--topo-order` располагает родителей позади потомков,
  но тем не менее вывод упорядочен по времени коммита.

---

## Флаг-фильтр --grep

Поиск всех коммитов в описании которых есть слово word:
`git log --grep word`
сделаем регистронезависимым:
`git log --grep word -i`

`--grep` и `-S`
фильтруют коммиты с сообщениями/изменениями кода,
которые содержат указанную строку.
например,
`--grep` смотрит на сообщения логов.

`git log -S имя_функции` позволяет посмотреть добавление/удаление функции;

---

### git grep

По заданному регулярному выражению.
ищет по файлам среди коммитов!

**Не путайте git grep с git log --grep!**

- git grep ищет по файлам среди коммитов,
- git log --grep смотрит на сообщения логов

---

## 9 Подготовка файлов

Добавить файл в репозиторий перед коммитом - проиндексировать изменения

```bush
git add scr/index.html
git add hello.txt
git add <filename> <filename>
```

- Добавить ВСЕ файлы из текущей директории в репозиторий перед коммитом (точка в команде обязательна!, иначе не работает)
  `$ git add .`

- Добавить не только все, что находится в директории, но еще и удалённые файлы, не только из текущей директории, но и из всего локального репозитория!
  `$ git add -A`

### 9.1 Удалить файл из индекса

Для удаления файла из git-репозитория без его физического удаления:

```bash
git rm --cached path/to/file
```

Для удаления папки (рекурсивно) можно сделать так:

```bash
git rm -r --cached folderName
```

Здесь `-r` это рекурсивность, `--cached` указание на индекс

А для того, чтобы ситуация не повторялась, лучше добавьте файл или папку в **.gitignore.**

---

## 10 Отмена последней индексации

`git restore --staged <file>`
`git restore --staged .`
ставим точку вместо указания конкретного файла для общей отмены!

---

## 11 Сравнение коммитов - Git Diff

- ### Вы можете генерировать diff между любыми двумя версиями вашего проекта используя git diff

- ### Узнать, какие изменения будут проиндексированы

`$ git diff`

- ### Узнать что именно будет добавлено в коммит

`$ git diff --cached`

`$ git diff master..test`
Это сгенерирует diff между последними коммитами двух ветвей разработки.
Если вы предпочитаете найти diff от их общего предка к ветке test, вы можете использовать три точки вместо двух:

`$ git diff master...test`
$ git diff
Это покажет изменения в вашей рабочей директории которые еще не были добавлены в индекс для последующего коммита.

`$ git diff --cached`
покажет вам различия между индексом и вашим последним коммитом; то что вы бы закоммитили, если выполнили коммит командой "git commit" без параметра "-a".

В заключении вы можете выполнить
`$ git diff HEAD`
что покажет изменения в рабочей директории от последнего коммита; то что вы бы закоммитили если выполнили команду "git commit -a".

Если вы хотите увидеть как ваша рабочая директория отличается от состояния проекта в другой ветке, то выполните команду
$ git diff test

---

## 12 Коммит

`git commit` вызывается редактор для описания коммита

Как альтернатива, вместо предварительного выполнения команды git add,
вы можете использовать следующую команду
`$ git commit -a`
эта команда будет автоматически определять измененные файлы (но не новые файлы), добавлять их в индекс, и затем коммитить, и все это за один шаг.

---

## 13 Создать новую ветку

[git-switch](https://git-scm.com/docs/git-switch)

При создании новой ветки создается новый указатель,
который автоматически сдвигается вперед (при каждом коммите).

`git branch <new_branch_name>`

- Посмотреть на все ветки
  `git branch` будет обозначена текущая ветка

- Переключение на ветку
  `git switch <branch>`

Начиная с Git версии 2.23, вы можете использовать git switch вместо git
checkout, чтобы:

- Переключиться на существующую ветку: `git switch testing-branch`

- Создать новую ветку и переключиться на нее: `git switch -c new-branch`
- Флаг `-c` означает создание, но также можно использовать полный
  формат: `--create`.

- Вернуться к предыдущей извлечённой ветке:
  `git switch -`

### Создаем ветку и переключаемся на нее

- `git checkout -b <new_branch_name>`

- `git switch -c <new_branch_name>`

#### Создаем ветку и переключаемся на нее `-b` привязка к удаленной ветке

- `git checkout -b prev-master-search origin/prev-master-search`

- `git checkout -b new_branch origin/new_branch`

---

## 14 Включить изменения из ветки feature в ветку master

выполните
`$ git merge feature`

Если же существуют какие либо конфликты, то в проблемных файлах останутся заметки которые можно увидеть выполнив
`git diff`

---

## 15 Перенести мастер на новую позицию

`git branch master <hash>`

можно использовать ключ **force** `-f или --force`

---

## 16 Переключение на коммит

- 1. найдите хэш для первого коммита - `$git logs`
- 2. Используйте этот хэш-код (достаточно первых 7 знаков)
     `git checkout <hash>`

### вернуться на первый коммит master ветки

`git checkout master`
`git switch master`

Переключая имена веток, вы попадаете на последнюю версию выбранной ветки.

---

## 17 Отмена локальных изменений до коммита

Данные команды удалят из индекса все файлы, которые были добавлены в индекс командой `git add`

- ````bash
        git checkout hello.html
      ```

  ````

- ```bash
        git restore path/file
  ```

---

### 18 Возврат состояния при ошибке

До введения команды git add можно сделать отмену изменений в самом файле и удаление файла

`git checkout имя-файла`

---

## 19 git reflog

покажет все коммиты, которые не видно после переключения по checkout

---

## 20 Изменение последнего коммита

Если вы что-то не сделали в последнем коммите, то отредактировать его не сложно. Все, что нужно это:

- добавить изменения в индекс обычным образом:
  `git add .`

- Сделать коммит изменения с параметром --amend:
  `git commit --amend`
  Эта команда берет индексированный файлы и включает в коммит всю обнаруженную там информацию.
- Чтобы изменить название коммита выполните:
  `git commit --amend -m "new name commit"`

---

## 21 Отмена изменение в файле

Итак, файлы могут быть возвращены в состояние последнего коммита с помощью команды:
`git checkout -- [name_file]`

Отметьте, что все что после `--` воспринимается как путь.

---

## 22 Получаем предыдущие версии файлов, не трогая остальные

`git checkout ()`

Допустим нам нужно вернуть версию файла, которая была два коммита назад.
При этом нам требуется откатить лишь один файл.

- Восстановим файл index.html на момент конкретного коммита (0b335):
  `git checkout 0b335 index.html`
- Или откатим версию файла до состояния из текущего коммита (откатим изменения, которые нас не устраивают):
  `git checkout HEAD index.html`
  Что аналогично:
  `git checkout index.html`

---

## 23 Отмена коммитов

### Изменить сообщение последнего коммита

`$ git commit --amend`

### Коммит с новыми изменениями, отменяющими предыдущие

`git revert HEAD`

- Откроется редактор, в котором можно отредактировать сообщение для отменяющего коммита.
- Сохраните и закройте файл.
- Оригинальный и «отмененный» коммиты видны в истории ветки (при использовании команды git log).
- Так как мы отменили самый последний произведенный коммит, мы смогли использовать HEAD в качестве аргумента для отмены. Мы можем отменить любой произвольной коммит в истории, указав его хэш-значение.
- Эта техника будет работать с любым коммитом (хотя, возможно, возникнут конфликты). Она безопасна в использовании даже в публичных ветках удаленных репозиториев.

  ```bash
  Revert "wip(html): branch_4 - commit 2: cancel last commit"

  This reverts commit b01a73c23fff3c696b2d2294085d3394c521bd89.
  ```

### Удаление коммитов из ветки

**git reset** - отменяет изменения, перенося ссылку на ветку назад, на более старый коммит.
Это своего рода «переписывание истории»;

**Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.**

- Если вы сделали коммит, который впоследствии понадобилось отредактировать или полностью стереть, поможет команда git reset.
- `git reset HEAD~1` - отменить последний коммит, **сохранить изменения**
- `git reset --hard HEAD~1` - отменить последний коммит, **стереть изменения**
  **_Будьте осторожны используя второй вариант, поскольку изменения ваших локальных файлов будут потеряны!_**

  Ошибочные коммиты все еще находятся в репозитории. Просто они отсутствуют в ветке. Если бы мы не отметили их тегами, они по-прежнему находились бы в репозитории, но не было бы никакой возможности ссылаться на них, кроме как при помощи их хэш имен. **Коммиты, на которые нет ссылок, остаются в репозитории до тех пор, пока не будет запущен сборщик мусора!**
  `git gc`

- `git reset --hard v1` отменить коммиты до коммита с тегом **`v1`**

- Если вам нужно сохранить всё, что вы сделали, но еще не успели закоммитить, используйте:
  `git reset --soft HEAD~1`

### Отменить последний коммит

**~ задает количество коммитов для смещения назад!**
**^ возвращаемся на 1 коммит назад!**

Данная команда отменяет последний коммит. Файлы из данного последнего коммита переходят в статус `unstaged`, то есть в то состояние, в котором они были до коммита. Если запустить команду git status, то эти файлы будут находиться в списке «Changes not staged for commit». Содержимое файлов не изменяется.

`git reset HEAD~`
`git reset --soft HEAD~1`
`git reset --soft HEAD^`

Если вы хотите полностью удалить последний коммит, включая все изменения файлов данного коммита, то используется команда:
`git reset --hard HEAD~1`

Если передать путь к файлу/папке, то команда будет выполнена только для них

`git reset --soft HEAD~1 src/.`

---

## 24 Перенести конкретный файл в состояние на момент коммита **hash**, не затрагивая других файлов

`$ git cho <hash> src/file.html`

- достает один этот файл из заданного коммита

---

## 25 Перебазирование rebase

- Находимся в ветке bugFix. Делаем копию всех коммитов из bugFix в ветку master
  `(feature)$ git rebase master`
  Теперь изменения из bugFix находятся в конце ветки master и являют собой линейную последовательность коммитов.
- Требуется обновить master до последних изменений. Выберем ветку master.
  `(feature)$ git switch master`
- Делаем rebase на bugFix
  `(master)$ git rebase bugFix`
  Так как master был предком bugFix, git просто сдвинул ссылку на master вперёд.

---

## 26 Переключиться на коммит выше - на родителя

`git checkout master^`

- `git checkout HEAD^` - возвращаемся на 1 коммит назад
- `master^` означает "первый предок ветки master"
- `master^^` означает "предок предка ветки master"
- `git checkout HEAD~<num>` перемещение на **num** коммитов назад.
  **Здесь тильда**~**задает количество коммитов для смещения назад!**

---

## 27 branch forcing - напрямую прикрепить ветку к коммиту

- `git branch -f master HEAD~3` Переместит (принудительно) ветку master на ТРИ родителя назад от HEAD.
  Относительная ссылка дала нам возможность просто сослаться на C1, а branch forcing (-f) позволил быстро переместить указатель ветки на этот коммит.

---

## 28 Добавить новую локальную ветку в удаленный репозиторий Git и отследить её

```js
  git push -u origin <new-branch>
```

Git настроит отслеживание информации во время push.

---

## 29

---

## 30 revert — отменить изменения и поделиться отменёнными изменениями с остальными

**перемещает указатель HEAD, предоставляя более чистую историю (словно бы этого коммита никогда и не было)**
`git revert HEAD` - появился новый коммит.
Дело в том, что новый коммит C2′ просто содержит изменения, **полностью** противоположные тем, что сделаны в коммите C2.

После revert можно сделать push и поделиться изменениями с остальными.

---

## 31 Получение старых версий

Перешли на hash
`git checkout <hash>`
Вернулись на указатель
`git checkout master`

---

## 32 Создание тегов версий и переключение по тегам

- ### Создайте тег первой версии

  `git tag v1`

- Переключимся на предыдущий коммит
  `git checkout v1~1`
  или
  `git checkout v1^`

- Переключение по имени тега
  `git checkout v1`
  `git checkout v1-beta`

- Список всех доступных тегов
  `git tag`

- ### Удаление тега

  `git tag -d oops`

---

## 35 Отмена изменений для конкретного файла, не затрагивая других

`git checkout HEAD <file>`

### 35.1 Вернуть изменения из индекса (если файл уже проиндексирован)

`git checkout HEAD <file>`

---

## 36 Удаленные remote репозитории

- Загружаем себе копию репозитория, и неявно отслеживаем удалённый сервер, который находится по указанному адресу и которому присваивается имя **origin**.

  `git clone <url репозитория>` [клонируем репозиторий](https://pingvinus.ru/git/1573)

- Выводит список удалённых репозиториев, которые мы отслеживаем,
  и имена, которые мы им присвоили.
  `git remote -v`
- Добавляет удалённый репозиторий с заданным именем.
  `git remote add <имя>`
- Удаляет удалённый репозиторий с заданным именем.
  `git remote remove <имя>`
- Присваивает репозиторию с именем новый адрес.
  `git remote set-url <имя> <url>`
- Показывает информацию о репозитории.
  `git remote show <имя>`

### Работа с удаленными ветками

- `git fetch <имя> <ветка>`
  — получает данные из ветки заданного репозитория, но не сливает изменения;
  команда **«git fetch»** будет извлекать новые коммиты из удаленного репозитория, но не будет сливать их с вашими наработками в локальных ветках.

- `git merge origin/master`
  Слейте извлеченные изменения в локальную ветку master

- `git pull <имя> <ветка>`

  - сливает данные из ветки заданного репозитория: эквивалентно двум следующим шагам: git pull = git fetch + git merge

    ```bash
     git fetch
     git merge origin/master
    ```

  - против отслеживания восходящей ветки:
    git pull --rebase = git fetch + git rebase

    ```bash
    git pull --rebase
    ```

- `git push <имя> <ветка>`
  — отправляет изменения в ветку заданного репозитория. Если локальная ветка уже отслеживает удалённую, то можно использовать просто git push или git pull.

#### Привязка к удалённой ветке

##### Лучший вариант: `git checkout new_branch`

создаёт локальную ветку с таким же именем, как у удалённой, и начинает её отслеживать

##### Другие варианты

- `git branch --v`
  показывает локальные и отслеживаемые удалённые ветки
- `git push --set-upstream origin pre-master`
  в данном случае эта ветка может не существовать в origin
- `git branch -u <имя удалённого репозитория>/<удалённая ветка>`
  `$ git switch -c <branch> --track <remote>/<branch>`
- `git checkout --track <remote>/<branch>`
  привязывает текущую ветку к указанной удалённой ветке.
  Эта ветка уже должна существовать!
- `git checkout -b <ветка> <имя удалённого репозитория>/<удалённая ветка`
  создаёт новую локальную ветку и начинает отслеживать удалённую

---

## 37

---

## 38 Работа с ветками

В общем, **git checkout** связан с изменением места, на которое указывает **HEAD** ветки,
что похоже на то, как **git reset** перемещает общий **HEAD**.

### Переименовать локальную ветку

`git branch -m oldname newname`

### Команды ветвления

- `git branch <имя ветки>`
  создаёт новую ветку с HEAD, указывающим на HEAD.

- `git branch`
  вывод списка **локальных** веток!

- `git branch -a`
  вывод списка **локальных и удаленных** веток!

- `git checkout <имя ветки>`
  переключается на эту ветку.

- `git checkout <имя ветки> -b`
  создать новую ветку и переключиться на нее.

### Удаление веток

#### удалить ветку feature

`$ git branch -d feature`

- `git branch -d`
  Предназначен для удаления ветвей, которые полностью объединены в его восходящей ветви.Если ветвь не будет полностью объединена, она не будет выполнять удаление.

- `git branch -D`
  Удаляет ветвь, даже если она не объединена.

---

## 39 Спрятать изменения - Stash

Если у вас есть незавершённые изменения, которые нельзя фиксировать.

- `git stash`
  `git stash save`
  сохранить и спрятать изменения

- `git stash list`
  показать список спрятанных изменений

- `git stash apply`
  применить последние спрятанные изменения без удаления их из стека

- `git stash pop`
  применить последние спрятанные изменения и удалить их из стека

- `git stash clear`
  очистить stash

---

## 40 Слияние веток

Слияние включает в себя создание нового **коммита**,
который основан на общем коммите-предке двух ветвей **_base_** (основная) и **_feature_** (дополнительная) и указывает на оба **HEAD** в качестве предыдущих коммитов.

1. Перейти на **основную** ветку, в которую будет делаться слияние
2. `git merge <feature branch name>`
3. Если обе ветви меняют одну и ту же часть файла,
   то возникает конфликт слияния — ситуация, в которой Git не знает,
   какую версию файла сохранить, поэтому разрешать конфликт нужно собственноручно.
4. `git status`
   увидеть конфликтующие файлы
5. После разрешения всех конфликтов можно использовать `git commit` для завершения слияния.

---

## 41 Перемещение коммитов rebase

Вместо совмещения двух ветвей коммитом слияния,
перемещение заново воспроизводит коммиты тематической ветки
в виде набора новых коммитов базовой ветки,
что выливается в более чистую историю коммитов.

Перемещайте изменения только на вашей приватной локальной ветке
— не перемещайте коммиты, от которых зависит ещё кто-то.

`git rebase <основная ветка> <тематическая ветка>`
воспроизводит изменения **feature** ветки на основной;
HEAD **feature** ветки указывает на последний воспроизведённый коммит.

---

## 42 Перенос отдельного коммита - cherry-pick

Допустим, у вас есть локальная ветка drafts,
где вы работаете над несколькими потенциальными статьями,
но хотите опубликовать только одну из них.
`git`

---

## 43 Отмена действий с помощью git restore

По сути, это альтернатива git reset.
Начиная с версии 2.23.0, Git будет использовать git restore вместо git reset для многих операций отмены.
[git-restore](https://git-scm.com/docs/git-restore)

### Отмена индексации файла с помощью git restore

`git restore --staged <file>...`

### Откат измененного файла с помощью git restore

Что, если вы поймете, что не хотите сохранять изменения в файле?
Как легко его откатить — вернуть обратно к тому, как он выглядел при последнем коммите

`git restore <file>`
