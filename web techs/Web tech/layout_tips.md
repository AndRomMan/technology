    почти все пропорции цветов и углы наклона указаны в градусах и кратны 5;
	
    ширина белых полосок у Тринидада составляет 3%, а чёрной 14%;
	
#009543, #fbde4a, #dc241f

background: linear-gradient(135deg,);
==================
    Siteinspire
	webflow
	Данил Фурман
	
====== !!! ======

https://frontendmasters.com/books/front-end-handbook/2018/

Front-End on a Team
https://vk.com/htmlacademy        - ВКонтакте
https://facebook.com/htmlacademy  - Фейсбук
https://instagram.com/htmlacademy - Инстаграм

==================
Отмечу, что есть еще 4 значения, полезные в некоторых случаях:

    vertical-align: top / bottom выравнивают по верху или низу контейнера строки
    vertical-align: text-top / text-bottom выравнивают по верху или низу области содержимого

https://css-live.ru/css/metriki-shrifta-line-height-vertical-align.html

vertical-align принимает также числовые значения, которые поднимают или опускают бокс относительно базовой линии.
Этот последний вариант часто может выручить.

хорошо бы напомнить, что область содержимого находится ПОСЕРЕДИНЕ line-height

==================================
При проверке допускаются:
    Вертикальная погрешность не более 10 пикселей, горизонтальная погрешность не более 5 пикселей;
    Различия в отображении шрифтов, связанные со сглаживанием на различных платформах.
	
==================================
Предпочтите путь mobile-first, избегайте указания @media-условия max-width в пользу min-width.
Ширина адаптивно-фиксированного контейнера (container)

    320px — мобильная версия
    768px — планшетная версия
    1300px — десктопная версия
	
    /* xs (<=543px) */
    @media (max-width: 575px) { ... }
	container: 320px или 100%
     
    /* sm (>=576 и <=767) */
    @media (min-width: 576px) and (max-width: 767px) { ... }
    container: 540px
	
    /* md (>=768 и <=991) */
    @media (min-width: 768px) and (max-width: 991px) { ... }
    container: 960px
	
    /* lg (>=992 и <=1199) */
    @media (min-width: 992px) and (max-width: 1199px) { ... }
    container: 720px
     
    /* xl (>=1200) */
    @media (min-width: 1200px) { ... }
    container: 1140px
	
	orientation	
	Определяет, находится ли область просмотра в режиме 
	альбомной ориентации - экран шире, чем высота, 
	или в портретной ориентации - высота дисплея больше или равна ширине. Для альбомной ориентации используется значение: orientation: landscape, а для портретной и orientation: portrait.
	 
	 
	 @media (min-width: 30em) and (orientation: landscape) { ... }
	 
	 Запятая в значении "или"
@media (min-height: 680px), screen and (orientation: portrait) { ... }

@media (hover: hover) { ... }

==================================
Атрибут async — имеет смысл только в том случае, если скрипты по каким-то причинам расположены в head документа. Если скрипты расположены в footer то async бесполезен чуть более чем полностью. 

==================================
Везде, где это возможно, уберите неиспользуемый JavaScript-код, или постарайтесь, чтобы страница загружала бы только те скрипты, которые используются на этой странице.

==================================
Для достижения анимационного эффекта изменяйте свойства transform и opacity

Помните, что для использования свойств transform и opacity, элемент, для которого вы изменяете эти свойства, должен находиться на собственном слое. Чтобы создать слой, необходимо переместить на него элемент

По возможности, при анимации меняйте не отступы/размеры, а правила transform или opacity , подсчет таких изменений страницы затронет наименьшие по размеру области и будет выполнен не на центральном процессоре (который может быть занят чем-то другим), а на графическом.

==================================
Не оптимизируйте CSS до старта проекта

Хорошо сжимать css-файл, чтобы он быстрее подгрузился, но делать это нужно либо автоматически, либо непосредственно перед выпуском релиза. Преждевременная оптимизация усложняет разработку.
==================================

Вот подходящий пример использования атрибута title:

<input type="text" title="search">
<input type="submit" value="search">

==================================
Проблемы с контентом
– Проверяйте на переполнение контентом все блоки
– Переполнение — это не только больше абзацев, но и длинные слова
– Проверяйте блоки с меньшим количеством контента
– Проверяйте переполнение страницы новыми блоками
– Убедитесь, что удаление блоков со страницы не ломает её структуру
– Проверяйте страницу с другими картинками и без картинок

==================================
Картинки
– Картинки должны иметь прописанные размеры
– Вставьте случайные картинки из интернета
– Удалите папку с картинками и проверьте вёрстку
– Проверьте ретину

==================================
Ограничения CMS
– Убедитесь что ваши одинаковые компоненты не дублируются с разными кодом
– Не стилизуйте формы и контент по классам
– Уточняйте возможную структуру компонентов до начала работы
– Не применяйте стилизацию к шаблонным блокам
– Пишите JS так, чтобы он работал на всех страницах
– Подключайте все стили и скрипты на все страницы

==================================
К img не добавлять КЛАССЫ!
Классы не добавлять и для контентной наполняемой области, особенно формы!

==================================
для SVG 
 role="img" aria-label="Описание." Точка в тексте areal-label важна для паузы ридера
 
 Атрибут  aria-label  создаёт текстовую метку текущего элемента в случае отсутствия видимого текста описания элемента. Если есть видимый текст, обозначающий элемент, используйте вместо этого aria-labelledby.
 
  
 В примере ниже, кнопка стилизована под типичную кнопку "закрыть" с X посередине. Поскольку нет ничего обозначающего значение того, что кнопка закрывает диалог, то aria-label атрибут используется чтобы обеспечить метку для любой вспомогающей технологии.
 
 <button aria-label="Close">X</button>
 
<a href="goods-description.html" aria-label="Перейти на страницу описания товара" target="_blank">

<a href="goods-new.html" aria-label="Перейти на страницу новых товаров" target="_blank">

<a href="goods-order.html" aria-label="Перейти на страницу оформления заказа" target="_blank">

==================================
Декоративная иконка
<button type="button" aria-label="Закрыть окно">
<svg aria-hidden="true" focusable="false">
<use xlink:href="#icon-close"></use>
</svg>
</button

Иконка-ссылка без текста
<a href="https://htmlacademy.ru/" aria-label="Сайт HTML Academy">
<svg role="img">
<use xlink:href="#icon-htmlacademy-logo"></use>
</svg>
</a>

Иконка-ссылка с текстом
<a href="https://htmlacademy.ru" aria-label="Сайт HTML Academy">
<svg role="img">
<use xlink:href="#icon-htmlacademy-logo"></use>
</svg>
HTML Academy
</a>

<svg class="icon">
  <use xlink:href="sprite.svg#github"></use>
</svg>


<a class="user-list__login" href="login.html">
	<svg class="user-list__login-icon" width="16" height="16">
		<use xlink:href="#icon-login"></use>
	</svg>Войти
</a>
 
<a>
	<svg class="site-list__icon-comb" width="16" height="16">
		<use xlink:href="img/sprite.svg#icon-comb"></use>
	</svg>
	Главная
</a>

==================================
https://github.com/iamstarkov/CSS-Guidelines/blob/master/README%20Russian.md
Классы в HTML

Для большей читаемости разделяйте классы в разметке двумя (2) пробелами:
<div class="foo--bar  bar__baz">

      <symbol id="ring" viewbox="0 0 150 150">
        <g>
          <circle class="ring" r="65" cx="75" cy="75" stroke-width="5" stroke="#ffdc00" fill="none"></circle>
          
          <path ... stroke="none" transform="translate(40, 35)" fill="currentColor"/>
        </g>
Можно использовать значение currentColor. Если назначить форме внутри символа спрайта свойство fill со значением currentColor, то цвет заливки этой формы будет браться из свойства color, то есть цвета текста, родительского элемента.
==================================
    /* Убираем пробелы между ячейками сетки */
    font-size: 0; 
==================================
==================================
 Cписок определений (dl). 
 Он предназначен для разметки пар имя—значение в содержимом. Это понятие может включать в себя всё, 
 от списка предлагаемых услуг с их описаниями до простого компонента «предыдущая статья / следующая статья».
 Этот элемент идеально подходит для документирования истории правок страницы, причин и следствий, или, на удивление, вообще любого списка, в котором используется группировка с заголовками. 
 
==================================
::before
Созданные элементы по умолчанию inline-элементы,
 поэтому при указании высоты или ширины необходимо установить display: block:
 Если псевдоэлементу before нужно установить другое отображение, то его нужно указать явно (например: display: block).
 
 Псевдоэлементы могут быть использованы вместе с псевдоклассами:
  
.image__over:hover::after,
.image__over:focus::after {
  content: "";
  position: absolute;
  }
  
==================================
Не допускайте ID в своих селекторах.
Не используйте несемантические типы селекторов (div и span, напр.) для любого неодиночного правила.
Не используйте больше двух комбинаторов в селекторе.
Простые элементы <div> и <span> не должны использоваться в HTML без назначенных классов.
Внимание, если один и тот же ID используется на странице два раза.
Не используйте классы, не упомянутые ни в одном из файлов стилей или передайте список разрешённых (с префиксом .js-, напр.)
Классы модификаторов не должны использоваться без их базовых классов.
Классы вложенных объектов не должны использоваться в отсутствие родительского базового класса.

==================================
Ссылки на ресурсы (картинки и т.п.) сделать переменными в SASS для быстрой замены ссылок с локальных на CDN

==================================
	Треть всех поисковых запросов в Google выходит на изображения и 12.5% страниц с результатами поиска показывают блоки(карточки) с результатами для изображений.
	Если картинка релевантна теме страницы или бизнес направлению вашего клиента (а если и нет, то возможно должно быть), вам точно нужно быть проиндексированным.
	Если вы используете background-image, то тут вы в пролёте и у вас не может быть тега alt=””, чтобы отдать Google описание и контекст изображения.
	
==================================
Давайте призадумаемся. Одна треть или 33% всех запросов в Google выходит на изображения. Если картинка релевантна теме страницы или бизнес направлению вашего клиента (а если и нет, то возможно должно быть), вам точно нужно быть проиндексированным.
Хорошо использовать background-image тогда, когда вам нужно просто фоновое изображение и ничего более.

==================================
html {
  background: url(greatimage.jpg), url(wonderfulimage.jpg);
  background-size: 300px 100px, cover;
  /* first image is 300x100, second image covers the whole area */
}

background: 
   url(number.png) 600px 10px no-repeat,  /* On top,    like z-index: 4; */
   url(thingy.png) 10px 10px no-repeat,   /*            like z-index: 3; */
   url(Paper-4.png);                      /* On bottom, like z-index: 1; */
   


=======================================
   #fourvalues {
  background-position: right 45px bottom 20px;
}
==================================
Стоит ли задавать line-height однострочным блокам? Конечно! В разных браузерах значения по умолчанию могут быть разными, поэтому всегда выставляйте line-height.

==================================
Если расстояние между элементами 51px, можно сделать 50. Большие расстояния я округляю до 5. Большие — это как раз за 50. Средние позволяю себе округлять до чётных. Из 31 сделаю 32. Размеры шрифтов не округляю и вам не советую. Буквы при изменении кегля меняются не пропорционально. Числа меньше 28 тоже стараюсь не округлять: при таких размерах обычно каждый пиксель важен.

Самое главное: сделайте, чтобы каждый блок походил на свой портрет в макете. Когда вы округлили пару-тройку отступов, и поставили макет в левый верхний угол, что-то внизу страницы может не совпасть с макетом. Это не страшно. Главное, чтобы каждый блок попадал в макет с допустимой погрешностью, если макет на него надвинуть.

==================================
В общем случае компоненты должны определять свой внешний вид, а не раскладку и позиционирование.
 Будьте осторожны, когда видите свойства вроде background, color и font в одном правиле с position, width, height и margin.  
 
 Раскладку и позиционирование стоит задавать либо отдельным классом для раскладки, либо использовать для этого отдельный элемент. (Помните, что для эффективного разделения содержимого и представления часто необходимо отделить содержимое от его контейнера).
 
 Мой совет — добавлять префикс ко всем неоформительским классам. Я использую .js- для JavaScript и .supports- для классов Modernizr. Все классы без префикса — для оформления и только для оформления.
 
==================================
 inline-block.

Блочно-строчные элементы ведут себя двояко. Снаружи они выглядят как обычные строчные, но внутри они ведут себя как блочные.От строчных им достались следующие черты:

    по ширине они ужимаются под своё содержимое;
    могут располагаться в одну строку;
    реагируют на вертикальное выравнивание, vertical-align;
    реагируют на горизонтальное выравнивание, text-align, заданное у родителя.

От блочных:

    им можно задавать размеры с помощью width и height;
    а также внешние и внутренние отступы и рамки, которые работают во всех направлениях и увеличивают размер элемента.
	
 ==================================
 https://up.htmlacademy.ru/htmlcss/26/module/8/lecture
 В лекции к модулю 8 курса на 1:35 мин. Вадим объясняет правомерность использования <br> для подгонки к PP. Верстка должна быть унифицирована под любой контент.
  Также разрешено использовать <br> внутри абзацев, если нет возможности сделать переносы как в макете с помощью ограничения ширины контейнера с текстом или вставки неразрывных пробелов.
  
 ==================================
   Текст на мобильных отодвинут от краёв на 20px, на планшетах на 40px, а на десктопе занимает 900px и находится по центру. Большинство адаптивных сайтов сделано именно так:

    фон всегда по ширине страницы;
    на мобильных и планшетах есть отступы у контента (могут быть как в пикселях, так и в процентах);
    есть максимальная ширина, больше контент не должен быть.
	
======================================
Боремся с выпадением margin по вертикали

Родительскому блоку можно
задать одно из следующих
свойств:
– overflow: hidden;
– padding-top: 1px;
Задать border 
– border-top: 1px solid transparent;
- border-bottom: 1px solid transparent;

Сейчас проблема с выпадающими или схлопывающимися маргинами при построении сеток уже не стоит так остро. Ведь для сеток мы используем флексбокс, а в нём эти эффекты не действуют.

======================================
Из-за схлопывания, хорошим решением будет предложить последовательный способ работы с margin на вашем сайте. Самое простое, что можно предпринять, это взять за правило задавать margin только сверху или снизу элементов. В этом случае вы не должны сталкиваться с проблемами схлопывания слишком часто, так как сторона, на которой задан margin, всегда будет смежной со стороной другого элемента без margin.

Как бороться с выпаданием?
Родительскому блоку можно
задать одно из следующих
свойств:
– padding-top: 1px;
– border-top: 1px solid transparent;

======================================
   img/rope-frame.png
    img/keks-2.jpg
    img/eye-patch.svg
Стрелки на CSS рассмотрены в разделе "Рамки и фоны"

======================================
1. Старайтесь не использовать одновременно width и height, если это не
декоративный элемент с фиксированными размерами.
2. Старайтесь не задавать фиксированную высоту.
3. Если всё-таки нужна высота, то лучше использовать min-height.

======================================
  html {
    box-sizing: border-box;
  }
  
    *, *::before, *::after {
    box-sizing: inherit;
  }
  
======================================
  Алгоритм работы со шрифтом
1. Проверяем, стандартный ли шрифт
2. Если нестандартный, ищем на внешних сервисах
3. Если нашли, подключаем из сервиса*
4. Если не нашли, конвертируем в веб-формат
5. Подключаем локально

 ====================================== Flex
  Важное правило: при построении сеток нужно всегда задавать либо flex-basis, либо width/height.
  Свойство flex-grow отвечает за гибкость на растяжение, или за «жадность» флекс-элемента. flex-grow может принимать числовые значения и по умолчанию равно нулю, то есть элементы по умолчанию не жадные. Если задать flex-grow значение больше нуля, то флекс-элемент становится жадным и начинает поглощать всё оставшееся в флекс-контейнере свободное пространство.
  
  Если флекс-элементам задать одинаковые положительные значения flex-grow, то они поровну поделят между собой свободное пространство. Если у флекс-элементов значения flex-grow будут отличаться, то свободное пространство поделится пропорционально этим значениям.
  
   Никогда не используйте flex-grow, если вам нужно точно управлять шириной. Например, чтобы каждая колонка была шириной ровно 30% родителя, нужно использовать width: 30% или flex-basis: 30%, но никак не flex-grow.
   
   Свойство flex-shrink отвечает за гибкость на сжатие. flex-shrink может принимать числовые значения и по умолчанию равно единице. Получается, что все флекс-элементы по умолчанию могут сжиматься, если после определения исходных базовых размеров выяснилось, что места во флекс-контейнере не хватает. Причём ужимается только область содержимого, а маргины, паддинги и рамки не ужимаются!
    Если идёт работа над сеткой, то лучше вообще отключить возможность сжатия у элементов-колонок.

======================================
Поэтому первое правило хорошего верстальщика, особенно при построении сеток, и вообще много где: не фиксировать высоту
Фиксировать ширину можно, потому что вы так или иначе верстаете по макету и есть направляющие, которые задают ширину колонок, но высоту фиксировать нельзя. Нужной высоты блоков необходимо добиваться за счёт высоты контента и внутренних отступов.


рекомендованные для моментально отображаемого контента рамки в 14КБ.

======================================
Теперь касательно стилей компонента. Здесь действуют те же самые правила:

Я думаю, дела обстоят так: бывают случаи, когда вам необходимо использовать rem и em, они описаны в спецификации. Но, сценариев использования, которые реально полезны, не так много, как может показаться на первый взгляд.

Поэтому, не ищите повода использовать em и rem. Используйте пикселы, а там, где rem и em будет лучшим решением – примените их.

Значение line-height можно указать при помощи px или em, но гораздо лучше – задать его числом.
Значение-число интерпретируется как множитель относительно размера шрифта. Например, значение с множителем line-height: 2 при font-size: 16px будет аналогично line-height: 32px (=16px*2).

Значение, заданное в единицах измерения, запоминается и наследуется «как есть».
Это означает, что line-height: 32px будет всегда жёстко задавать высоту строки, даже если шрифт во вложенных элементах станет больше или меньше текущего.

font: 20px/1.5 Arial,sans-serif;
font: italic bold 20px/1.5 Arial,sans-serif;

=================================
background-size: auto auto;   /* исходные ширина и высота изображения */
 background-size: contain; вписать 
 background-size: cover; закрыть всех

background-origin: content-box; border-box; padding-box;
задаёт расположение и размеры области отображения фонового изображения
 
background-clip: padding-box, border-box и content-box;
 управляет тем, как обрезается фон
 
 
 2 фоновых изображений, одно над другим.
 {
  background-color:  #ffffff;
  background-image:  url("img/glasses.svg"), url("img/keks.jpg");
  background-position: 75px 125px, center;
  background-clip: padding-box;
  background-origin: border-box;
  background-size: 150px, cover;
  background-repeat: no-repeat;
}


 background-position
/* по умолчанию координаты задаются для левого верхнего угла */
background-position: 10px 50px; /* слева 10px, сверху 50px */
background-position: right 30px bottom 60px; /* справа 30px, снизу 60px */
background-position: left 50px bottom 10px; /* слева 50px, снизу 10px */
background-position: right 40px top 30px; /* справа 40px, сверху 30px */


background-repeat: repeat 
повторяет фоновую картинку по всей ширине и высоте блока. Если части повторяющейся картинки не помещаются в ширину блока, то они просто обрезаются.

background-repeat: round, то повторяющиеся картинки по краям блока обрезаться не будут, а равномерно растянутся или сожмутся по всей ширине, чтобы занять оставшееся пространство.
 
 background-repeat: round repeat;
 
 background-repeat: space;
  фоновые картинки не сжимаются или растягиваются, а для компенсации ширины блока между ними добавляется пустое пространство.
background-repeat: space space;
  
 /* сплошная чёрная рамка толщиной 10px */
outline: 10px solid black;
  outline-offset можно изменять расположение рамки. Положительное значение отодвигает рамку от внешнего края элемента, а отрицательное «втягивает» внутрь.
  
  border-radius: 150px 50px 30px 100px; 4 радиуса для каждого угла свойства
  /* горизонтальный радиус 30px, вертикальный 15px */
border-top-right-radius: 30px 15px;

===============
  /* горизонтальный радиус всех углов 10px, вертикальный 5px */
border-radius: 10px / 5px;

===============
  /* разные горизонтальные и вертикальные радиусы у каждого угла */
border-radius: 10px 20px 30px 40px / 5px 15px 25px 35px;

===============
Задайте портрету скругление:
    верхних левого и правого углов — 100px 50px,
    нижних левого и правого углов — 20% 50%
  border-radius: 100px 100px 20% 20% / 50px 50px 50% 50%;
  
===============
Стрелка
[class^="arrow"] {
  display: inline-block;
  margin: 30px;
  width: 0;
  height: 0;
}
.arrow-top-right {
  border: 100px solid #ffffff;
  border-top-color:  #0074d9;
  border-bottom-width: 0;
  border-right-width: 0;
  border-left-color: transparent;
}
  
  
   border-image задаёт фоновое изображение для рамки блока
   border-image-source: url("image.jpg");
   
   border-image-slice задаёт отступы от краёв картинки до четырёх линий, которые «разрезают» её на части
   С помощью border-image-slice можно задавать разные отступы линий разреза. Для этого нужно задавать значения через пробел в порядке: верх, право, низ, лево.
   
border-image-slice: 10 20 30 40;
border-image-slice: 10 20 30 40 fill;
 средняя часть картинки будет отображаться в средней области рамки: она закроет собой фон блока, но не закроет содержимое
 
 border-image-repeat: четыре значения: stretch, repeat, space и round
 /* все стороны рамки заполняются в режиме stretch */
border-image-repeat: stretch;

/* горизонтальные стороны — режим repeat, вертикальные — stretch */
border-image-repeat: repeat stretch;

border-image-width: 10px 20px 30px 40px;

border-image-outset: 10px 20px 30px 40px;
позволяет отодвинуть рамку за пределы элемента, но при этом одновременно немного масштабируя картинку

==========================================
Следует отметить, что если одиночная строка может включать от 45 до 75 символов, чтобы быть читабельной, то для колонок текста рекомендуется придерживаться ширины, включающей 40-50 символов.

===============
Работают на всех браузерах
Tab вперёд
Shift Tab назад
Space нажать
Enter перейти по ссылке

===============
Порядок элементов
Лучше разделять ховеры и фокусы
Явные ховеры могут быть ленивыми фокусами
Не отключайте фокус, делайте его лучше
Фокус идёт по порядку в HTML-коде
Осторожнее со свойствами, меняющими порядок

===============
Это <button>
Если нет, то <a href="…">
Всё.

===============
Попасть в порядок
tabindex управляет фокусом
tabindex="0" добавляет в порядок
tabindex="-1" делает интерактивным, но не попадает в ряд элементов по которым переходит курсор при нажатии TAB. Нужен обработчик Jscript.
tabindex больше 0 проблемный

===============
Имитация кнопки
Добавить tabindex="0" для интерактивности;
Приделать обработчик click и слушать клавиши;
Добавить способ деактивации в стили и скрипты;
Объяснить читалке, что это кнопка и на неё можно нажать;
…или просто использовать <button> 

===============

===============

===============

===============

===============

===============
Размер img-pattern для копирования в фоновом изображении 4х4 8х8 16х16.

Пятизвездочная система рейтинга представляется в виде группы из 5 отдельных изображений звезды.

В таких случаях информация, передаваемая группой изображений должна быть размещена в атрибуте alt лишь у одного из них, у всех остальных изображений он должен быть оставлен пустым.
<img src="star.png" alt="4 out of 5 stars">  

Идеал модульной сетки — 12 колонок. Ибо 12 делится на 2, 3, 4 и 6.
Между колонками может быть пустое место, пропорциональное ширине колонки. К примеру, блоки в 12-колоночном ряду могут распределяться так: 2-колоночный блок, 1 колонка «пустоты», 9-колоночный блок.

Интерлиньяж не должен быть меньше размера шрифта. 

Избегайте менять кернинг и трекинг. 

В вебе нет кроссбраузерных переносов. Лучше не использовать переносы слов вообще. 
Всегда думайте о переполнении блока текстом или другими блоками. Всегда. Почти для всех блоков нужно предусматривать возможность переполнения. Это самое важное с точки зрения технической реализации макета в вёрстке.

Однотипные блоки должны иметь однотипные свойства. То есть, одинаковую ширину, высоту, цвет бордюра и пр.

===============

<video controls>
  <source src="video.mp4" type="video/mp4">
  <source src="video.ogv" type="video/ogg">
  <source src="video.webm" type="video/webm">
</video>

input[type=radio] + label {...}
input[type=radio]:checked + label {...}
input[type=radio]:disabled + label {...}

#F2A097

На момент написания главы псевдоклассы :read-write и :read-only в браузере Mozilla Firefox работают только с префиксом -moz-. Для прохождения задания в Firefox используйте псевдоклассы :-moz-read-only и :-moz-read-write.


input:-moz-read-only {
 background: #ecf0f1; 
 color: #bdc3c7;
}
	
<fieldset>
  <legend>Заголовок группы</legend>
  <input type="text">
</fieldset>

==================
background: [bc] [bi] [br] [bp] [ba];
/* Обозначения:
[bc] — background-color
[bi] — background-image
[br] — background-repeat
[bp] — background-position
[ba] — background-attachment
*/

================== Комбинации селекторов
селектор ребенок >
селектор смежный брат +
селектор общий брат ~

==================
/* Оформит все элементы имеющие атрибут src */
[src]
{
border:solid green 3px;
}

/* Свойства будут применены только к тем элементам p, которые находятся внутри элементов div */
div p
{
color:green;
font-family:verdana;
font-size:1.2em;
}

/* Свойства будут применены только к тем элементам p, которые идут сразу после элементов div */
div+p
{
color:green;
font-family:verdana;
font-size:1.2em;
}


p > a { /* выбирает любой элемент <a> дочерний по отношению к <p> */
блок объявлений;
}


Что касается смежных элементов, то для того, чтобы нам выбрать все элементы <p>, которые следуют сразу за <h2>, то нам необходимо создать следующий селектор:
h2+p {
блок объявлений;
}


Для того, чтобы нам выбрать все элементы <p>, которые следуют сразу за <h2> и элементы <p>), которые являются сестринскими по отношению к друг другу, нам необходимо создать следующий селектор:
h2~p {
блок объявлений;
}

==================
Удаление пространства между строчно-блочными элементами
1)
<header>...</header>
<section>
  ...
  </section><section>
  ...
  </section><section>
  ...
</section>
<footer>...</footer>

2)
<header>...</header>
<section>
  ...
</section><!--
--><section>
  ...
</section><!--
--><section>
  ...
</section>
<footer>...</footer>

Я склоняюсь в пользу применения комментариев для лучшей организации

====== !!! ======
.dialog {
  width: 260px;
  left: 0; right: 0;
  margin-left: auto; margin-right: auto;
}

Таким образом, сочетание width, left, right и margin управляет выравниванием элементов.

====== !!! ======

© Nuances of programming, 2018-2019.
При копировании материала ссылка на источник обязательна. 
====== !!! ======
В CSS есть запись, которая фактически выполняет операцию логического умножения, «И». Селекторы, применяемые к одному элементу, в этом случае пишутся без пробелов:
.class1.class2 { }

====== Структура сайта ======

<header>

  Я шапка сайта. Могу повторяться на других страницах.
  <nav></nav>
  
</header>
  
<main>
	<nav>
	Не каждая группа ссылок на странице должна быть обёрнута в <nav>. Например, небольшой блок со вспомогательными ссылками в подвале сайта. Такой блок внутри тега <footer> не нужно дополнительно оборачивать в тег <nav>.

	Кроме того, блок <nav> помимо ссылок может включать абзацы с текстом, заголовки, списки и другое содержание.
	</nav>
	
	 <article>
		Я основной контент! Живу только на этой странице.

		Я фотка в Инстаграм, смотрюсь отлично где угодно
	</article>
<section>
Тег <section>, обозначает крупный смысловой (или «логический») раздел. Как понять, что раздел смысловой? Если вы можете дать ему имя, описывающее его содержание или назначение, то это точно он.
</section>

<section>
  Раздел «О компании» Хм, наверное в нём будет описание компании
</section>

<section>
  Раздел «Редактирование профиля» Ага, здесь я управляю личными данными
</section>

</main>

<footer>
  Я подвал сайта, я как шапка могу повторяться.
</footer>

Обычно на странице появляется по одному тегу <header> и <footer>, но их может быть и больше.

 На главной <nav> был уникальным и попал в <main>, на внутренних <nav> повторяется, поэтому мы поместим его в <header>.
 
Полезно научиться отличать смысловые или логические разделы от структурных разделов. Логический раздел вы можете осмысленно назвать одним словом или сложноподчинённым словосочетанием: «программа обучения», «каталог», «наши преимущества».

Структурный раздел назвать сложнее. Вам в голову будут приходить названия, указывающие на его положение на странице («шапка», «подвал», «левая колонка»), либо сложносочинённые словосочетания («новости и галерея», «фильтры и товары»). Если сталкиваетесь с подобным, значит раздел структурный и <section> для него не подходит.

 Тег <article>, который обозначает цельный, законченный и самостоятельный фрагмент информации. А пост в блоге именно такой.

Тег <article>, в отличие от <section>, можно вырвать из одного места и вставить в другое (на другую страницу сайта или на другой сайт), и смысл содержимого тега при этом не потеряется. Примеры: статья, пост в блоге, сообщение на форуме и так далее.

Теги <section> можно использовать внутри <article>, если там нужно выделить отдельные смысловые блоки.

Точно так же можно использовать <article> внутри <section>, если в логическом разделе документа содержатся независимые контентные блоки.

====== !!! ======
Различают следующие основные типы макетов сайтов, связанных с шириной:

    фиксированный: жесткая разметка размеров блоков и их 
	расположения в px.
	
    резиновый (гибкий):
		разметка, в которой блоки имеют не строго фиксированную 
		ширину, а резиновую (обычно заданную в процентах). 
		Такой макет в отличие от фиксированного может 
		«подстраиваться» под размеры монитора.
	
    адаптивный:
	макет, который может «приспосабливаться» под различные
	устройства (ширину рабочей области окна браузера viewport).
	Т.е. на одних устройствах он может иметь одну структуру,
	а на других - другую.
	
	Фреймворки Bootstrap спроектированы для создания
	адаптивных 	сайтов. 

====== !!! ======
    Адаптивная - это такая разметка, которую можно настроить под различные размеры экранов.
	Осуществляется создание адаптивной разметки с помощью медиа запросов
	Настройка meta viewport для адаптивных веб-страниц
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	Если экран имеет плотность меньше 200ppi, то CSS-разрешение будет равно физическому. Если экран имеет плотность пикселей от 200 до 300 (ppi), то CSS-разрешение будет в 1.5 раза меньше физического. 
	А если экран имеет плотность более 300ppi, то CSS разрешение будет определяться делением физического разрешения на некоторый коэффициент. Данный коэффициент определяется по формуле=плотность/150ppi с округлением обычно до ближайшего числа из ряда: 2.2 до 2, 2.5, 3, 3.5, 3.6 до 4 и т.д. 
	 В большинстве случаев эта цифра целое число. 
	 Устанавливает значение CSS pixel-ratio производитель устройства. 
Узнать значение данного параметра у устройства можно, например на странице mydevice.io.
	
	Apple iPhone 6: 
	физическое разрешение 750x1344, 
	плотность пикселей - 326ppi. 
	Плотность пикселей больше 300, следовательно, CSS коэффициент будет равен 
	326/150=2 (2.2 округляем до 2).
	CSS разрешение будет равно 375x667.
	
	Кроме того, разработчики браузеров позаботились даже о тех, кому трудно добавить эту строчку. В этом случае экран устройства будет по умолчанию иметь CSS ширину, равную 980px. Т.е. ширини Viewport по умолчанию 980px.
	
====== !!! ======
	Обычно элемент является ссылкой, если есть подозрение, что он может привести к переходу на другую страницу.
В магазине кнопка «Заказать» ведет на страницу оформления заказа, поэтому это ссылка. Ведь если перед вами ссылка, то надо использовать тег <a>, а если кнопка, то тег <button>. 

====== !!! ======
Стили CSS в этом примере будут применяться к странице в двух случаях. Т.е. тогда, когда устройство будет иметь viewport не менее 544 пикселей (включительно) или ориентацию landscape. 
@media (min-width: 544px), (orientation: landscape) { /* Стили CSS ... */ }

Имеется возможность задать промежуток значений, если в этом есть необходимость:
Наши CSS-свойства будут работать непосредственно на экранах, с шириной 320-480px.
	
@media screen and (max-width:480px) and (min-width:320px) {
//необходимые CSS-правила
}

==============================================================================
Предпочтите путь mobile-first, избегайте указания @media-условия max-width в пользу min-width.
==============================================================================
/* Общие правила CSS для всех экранов, включая смартфоны */
Сначала идут мобильные с экраном меньше 767px, а потом экраны с большей шириной
      
@media (min-width: 768px) {
  /* Правила для планшетов и больших экранов от 768px */
}
      
@media (min-width: 992px) {
  /* Правила для ноутбуков и компьютеров от 992px  */
}
      
@media (min-width: 1200px) {
  /* Правила только для больших экранов  от 1200px*/
}
====== !!! ======
Обратите внимание, что в случае «сначала настольные» значения min-width на единицу меньше, 
чем значения max-width в подходе «сначала мобильные». 
Например:

    @media (min-width: 768px) нацелено на планшеты;
    @media (max-width: 767px) нацелено НЕ на планшеты, а на десктопы!
	
====== !!! ======
    Выберите подходящий стандартный формат: GIF, PNG или JPEG.
	
    Попробуйте установить разные настройки для каждого формата (качество, размер палитры и т. д.) и выберите наиболее подходящие.
	
    Для современных клиентов добавьте ресурсы в форматах WebP и JPEG XR масштабированные изображения:
	
    Масштабирование изображений - один из самых простых и эффективных методов оптимизации.
    Если вы используете изображения большого размера, пользователь может скачивать лишние данные.
    Снизьте количество ненужных пикселей, уменьшив изображение до отображаемого размера.

Поскольку WebP and JPEG XR поддерживаются не во всех браузерах, вам надо добавить дополнительную логику в приложения или на серверы, чтобы отправлять пользователю соответствующий ресурс.


Помните о некоторых советах и техниках, которые помогут вам оптимизировать изображения:

    Выбирайте изображения в векторных форматах. Их качество не зависит от разрешения и масштаба, поэтому они подходят для больших экранов и разных типов устройств.
	
    ** Минифицируйте и сжимайте SVG-ресурсы.** Многие графические приложения добавляют XML-разметку, которая часто содержит ненужные метаданные. Ее можно удалить. Убедитесь, что на серверах настроено GZIP-сжатие для SVG-ресурсов.
	
    Выбирайте наиболее подходящие растровые форматы. Определите необходимые требования к изображениям и выберите нужный формат для каждого ресурса.
	
    Пробуйте разные настройки качеств для растровых форматов. Не бойтесь снижать качество: часто изображение по-прежнему хорошо выглядит, а размер файла становится значительно меньше.
	
    Удаляйте ненужные метаданные. Многие растровые изображения содержат лишнюю информацию о ресурсе: геоданные, сведения о камере и т. д. Для их удаления используйте соответствующие инструменты.
	
    Масштабируйте изображения. Уменьшайте файлы на сервере, чтобы исходный и отображаемый размеры были практически одинаковы. Обратите особое внимание на большие изображения. Если их масштабирует браузер, производительность вашего сайта значительно снижается.
	
    Автоматизируйте. Используйте надежные инструменты и ПО, которые будут автоматически оптимизировать изображения на вашем сайте.
 	

Следует помнить, что в Фотошопе при качестве ниже 50 включается дополнительный алгоритм оптимизации — color downsampling. Суть его заключается в том, что дополнительно усредняется цвет в соседних восьмипиксельных блоках:

Поэтому если на изображении присутствуют очень мелкие контрастные детали, не следует выставлять качество ниже 51.
=================

Парсинг HTML

Движок рендеринга начинает получать содержимое запрашиваемого документа от сетевого механизма браузера. Как правило, контент поступает кусками по 8Кб. Главной задачей HTML-парсера является разбор разметки в специальное дерево.

Получающееся на выходе дерево («parse tree») — это дерево DOM-элементов и узлов атрибутов. DOM — сокращение от Document Object Model. Это модель объектного представления HTML-документа и интерфейс для взаимодействия HTML-элементов с «внешним миром» (например, JavaScript-кодом). Корнем дерева является объект «Документ». 


==================================
Расчёт итогового размера с flex-grow

1 шаг. Рассчитываем свободное место во флекс-контейнере:

Свободное место = Ширина контейнера - Сумма базовых размеров элементов

2 шаг. Считаем размер минимальной доли свободного места:

Доля свободного места = Свободное место / Сумма flex-grow всех элементов

3 шаг. Базовый размер каждого флекс-элемента увеличиваем на размер минимальной доли свободного места, умноженной на значение flex-grow этого элемента:

Итоговый размер = Базовый размер + (Доля свободного места * flex-grow)

==================================

Расчёт итогового размера с flex-shrink

Ниже описан механизм расчёта размеров элементов, когда места в контейнере не хватает:

1 шаг. Рассчитываем отрицательное пространство (ОП) во флекс-контейнере:

ОП = Ширина контейнера - Сумма базовых размеров элементов

2 шаг. Находим сумму произведений базовых размеров (СПБР) элементов на их коэффициенты сжатия:

СПБР = (Базовый размер1 * flex-shrink1) + (Базовый размер2 * flex-shrink2) + … + (Базовый размерn * flex-shrinkn)

3 шаг. Для каждого элемента считаем «нормированный коэффициент сжатия» (НКС), для чего произведение базового размера элемента на его коэффициент сжатия делим на СПБР:

НКС = (Базовый размер * flex-shrink) / СПБР

4 шаг. Базовый размер элемента уменьшаем на часть ОП пропорциональную НКС элемента. ОП для расчёта берём по модулю, то есть отбрасывая минус:

Итоговый размер = Базовый размер - (НКС * ОП)
==================================