
=======================================

Управлять стилями элемента можно с помощью свойства style
элемент.style.свойствоCSS
let element = document.querySelector('p');

// Зададим абзацу зелёный цвет текста
element.style.color = 'green';

==========
Цвет текста должен меняться, когда пользователь выбирает новое значение,
поэтому используем обработчик событий onchange.

// Находим выпадающий список
let select = document.queryS
elector('select');

// Добавляем списку обработчик событий
select.onchange = function () {
  // Меняем цвет текста на выбранное значение
  longread.style.color = select.value;
};

Размер текста (<span class="pixels">14</span>px)

Нам нужно получать значение, когда пользователь передвигает ползунок. Используем обработчик событий onchange.

// Находим поле и элемент для вывода значения
let range = document.querySelector('input');
let span = document.querySelector('span');

// Добавляем полю обработчик событий
range.onchange = function () {
  // Выводим значение на страницу
  span.textContent = range.value
}

 В JavaScript нельзя использовать дефисы в названиях свойств, вместо этого для разделения слов используется «верблюжий» стиль

font-size      = fontSize
background-color  = backgroundColor
border-left-width  = borderLeftWidth

let element = document.querySelector('p');

// Зададим абзацу размер шрифта 24px
element.style.fontSize = '24px';

Используем конкатенацию, чтобы получить правильное значение:
longread.style.fontSize = sizeSetting.value + 'px';

Представим, что пользователь выбрал с помощью ползунка число 16. Тогда в стили элемента запишется результат конкатенации — '16px':
<article class="longread" style="font-size: 16px">

=======================================
    onchange
  срабатывает, если значение поля ввода изменилось и пользователь закончил ввод. Например, если пользователь передвинул ползунок и отпустил его. Или ввёл что-то в текстовое поле и убрал из него курсор.

    oninput
  срабатывает на каждое изменение значения, независимо от того, завершил пользователь ввод или нет. Например, он сработает на каждое изменение положения ползунка, даже если пользователь продолжает его двигать. И на каждый новый символ в текстовом поле, даже если пользователь продолжает вводить текст.

sizeSetting.oninput = function () {
  pixels.textContent = sizeSetting.value;
  longread.style.fontSize = sizeSetting.value + 'px';
};
=======================================
// Проверяем, включён ли чекбокс
if (showPassword.checked) {
  // Показываем пароль
} else {
  // Прячем пароль
}
=======================================
Длина введённого значения хранится в его свойстве length.
let input = document.querySelector('input');

console.log(input.value); // Выведет: Кекс
console.log(input.value.length); // Выведет: 4

=======================================
Свойство style позволяет не только изменять стили, но и получать их. Правда, с его помощью можно узнать только те стили, которые заданы в разметке в атрибуте style самого элемента. Такие стили ещё называют встроенными.

Чтобы получить все стили, которые применяются к элементу, используйте метод window.getComputedStyle

backgroundSetting.onchange = function() {
  longread.style.backgroundColor = backgroundSetting.value;
}


let input = document.querySelector('input');
// Сделаем input текстовым полем ввода
input.type = 'text';

==================================
Обработчик события onscroll
window.onscroll = function() {};

==========================================
1) Клонируем элемент
var clonedElement = element.cloneNode(true);
console.log(clonedElement);
parent.appendChild(clonedElement);

2) Свойство children хранит в себе псевдо массив дочерних элементов.

Дочерними элементами считаются все теги, которые непосредственно расположены внутри блока.

<div id="parent">
  <p>1</p>
  <p>2</p>
  <p>3</p>
</div>

let parent = document.querySelector('#parent');
let elems = parent.children;

for (let elem of elems) {
  console.log(elem.innerHTML);
}

3)  Свойство childNodes хранит в себе псевдомассив дочерних узлов элемента (теги, комментарии и текстовые узлы).


 Выведем содержимое первого узла:
<div id="parent">текст<p>абзац</p><!-- коментарий --></div>
let parent = document.querySelector('#parent');
console.log(parent.childNodes[0].textContent);

Результат выполнения кода:
'текст'


================================
openPopupButton.addEventListener('click', function (evt) {
  evt.preventDefault();
  console.log('Клик по кнопке');
});
================================
обратиться к элементу объекта
 obj['key'], а obj.key.

    if (!product.isAvailable) {

    }

var thumbnails = document.querySelectorAll('.gallery__photo-preview');
var fullPhoto = document.querySelector('.full-photo');

for (var i = 0; i < thumbnails.length; i++) {
  thumbnails[i].addEventListener('click', function() {
    });
}

Добавляем элемент с текстовым содержанием

var price = document.createElement('p');
price.classList.add('product__price');
price.textContent = '1000';
listItem.appendChild(price);

Как проверить наличие параметра? Если параметр не был передан в функцию, его значение внутри функции будет равно undefined, то есть не определено. Значение undefined приводится к логическому значению false, поэтому достаточно такой простейшей проверки:

var createCard = function (required, optional) {
  if (optional) {
    // действия с optional
  }
}
}

// Функция отработает, но действия с optional выполняться не будут
createCard('Обязательный аргумент');

// Функция отработает и действия с optional выполнятся
createCard('Обязательный аргумент', 'Необязательный аргумент');




// Когда ищем элемент по классу, используем точку
var product = document.querySelector('.product');

// Но когда добавляем класс, точки нет!
product.classList.add('product--sale');
================================
В каждом DOM-дереве есть корневой объект, из которого «растут» другие объекты. Он называется document. Этот глобальный объект доступен во всех программах, которые работают в браузере. Проще говоря, document — страница, которая содержит все элементы разметки (объекты).
// Поиск элемента по тегу
var list = document.querySelector('ul');

// Поиск последнего элемента из списка
var lastProduct = document.querySelector('li:last-child');

// Поиск элемента по классу
var price = document.querySelector('.price');

// Поиск третьего элемента из списка товаров
var thirdProduct = document.querySelector('.product:nth-child(3)');

================================
// Найдёт все абзацы на странице
let elements = document.querySelectorAll('p');

console.log(elements[0]); // Выведет первый элемент коллекции
console.log(elements[1]); // Выведет второй элемент коллекции


tooltipButtons[0].onclick = function () {
  tooltip.classList.add('opened');
};

tooltipButtons[1].onclick = function () {
  tooltip.classList.add('opened');
};

<div data-cat-name="Кекс">
Атрибуты, начинающиеся с data-, обычно используют, чтобы хранить вспомогательную информацию

Как получить значение такого атрибута в JavaScript? Для этого используют свойство dataset, после которого указывают имя атрибута без префикса data-:

элемент.dataset.имяАтрибутаБезПрефикса

Чтобы получить значение атрибута из примера выше, нужно использовать такие инструкции:

let element = document.querySelector('div');
console.log(element.dataset.catName); // Выведет: Кекс



let elements = document.querySelectorAll('p'); // Находим все абзацы

for (let element of elements) {  // Создаём цикл и переменную
  console.log(element);          // Выводим элементы в консоль
}


Воспользуемся циклом: на каждой итерации будем добавлять обработчик элементу, который сейчас находится в переменной цикла. В результате мы получим универсальный скрипт — обработчик добавится каждому элементу в коллекции, сколько бы их ни было.


let elements = document.querySelectorAll('p');

for (let element of elements) {
  // Добавляем обработчик всем элементам по очереди
  element.onclick = function () {
    console.log('Вы кликнули на абзац!');
  };
}

Инструкции внутри обработчика oninput выполняются каждый раз, когда значение в поле ввода меняется. Например:

// Найдём поле ввода
let textarea = document.querySelector('textarea');

// Добавим обработчик событий
textarea.oninput = function () {
  // Выведем данные из поля ввода
  console.log(textarea.value);
};


Узнать длину комментария нам поможет свойство length (по-английски «длина»). Значение этого свойства равно числу символов в строке. Символами считаются не только буквы и цифры, но также пробелы и переносы строки.

let text = 'Я люблю JavaScript';
console.log(text.length); // Выведет: 18

let textarea = document.querySelector('textarea');
console.log(textarea.value); // Выведет: Кекс
console.log(textarea.value.length); // Выведет: 4

Блокировать и разблокировать кнопку в JavaScript можно, присваивая булевы значения свойству disabled (по-английски значит «отключён») этой кнопки. Если присвоено значение true, то кнопка заблокирована, а если false — разблокирована.

let button = document.querySelector('button');

// Блокирует кнопку
button.disabled = true;

// Разблокирует кнопку
button.disabled = false;

========================
let input = document.querySelector('input');
let paragraph = document.querySelector('p');

// Записываем данные из поля ввода в текстовое содержимое элемента
paragraph.textContent = input.value;

Данные из поля ввода мы запишем вместо «рыбы» в textContent созданного нами элемента. А само поле ввода после этого очистим, чтобы пользователь по ошибке не отправил один и тот же комментарий несколько раз. Для этого в свойство value поля ввода запишем пустую строку. Вот так:

input.value = '';


// Создаём новый абзац
let newElement = document.createElement('p');

// Меняем текстовое содержимое
newElement.textContent = 'Я новый абзац!';

// Добавляем класс
newElement.classList.add('some-text');

// Добавляем элемент на страницу
parent.append(newElement);

let element = document.querySelector('div');
if (element.classList.contains('some-class')) {
  // Сообщение выведется, только если класс у элемента есть
  console.log('Условие истинно');
}

==================================
выйти из цикла в любой момент с помощью специальной директивы
break
  if (!value) break;

 Директива continue – «облегчённая версия» break.
При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

==================================
Стрелочная функция

let func = function(arg1, arg2, ...argN) {
  return expression;
};
Эквивалент
let sum = (a, b) => a + b;

Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить:
let double = n => n * 2;

Если нет аргументов, указываются пустые круглые скобки:
let sayHi = () => alert("Hello!");

let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет') :
  () => alert("Здравствуйте!");

welcome(); // теперь всё в порядке

let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // при фигурных скобках для возврата значения нужно явно вызвать return
};

alert( sum(1, 2) ); // 3

==================================
Функции

Результат функции с пустым return или без него – undefined

Никогда не добавляйте перевод строки между return и его значением

function sum(a, b) {
  return a + b;
}


function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

Пустой return аналогичен return undefined:

function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true

==================================
метод querySelectorAll, который возвращает не первый найденный элемент, а список (коллекцию) всех элементов, подходящих по селектору.

==================================

document — страница, которая содержит все элементы разметки (объекты)
==================================
Допустим, на странице есть поле ввода input:
<input type="text">

Босс проходил мимо и ввёл туда своё имя — Кекс.
 С помощью свойства value мы можем получить данные из этого поля ввода. А после, например, вывести их в консоль:

let input = document.querySelector('input');
console.log(input.value);
// Выведет: Кекс

 Для JavaScript поля формы не имеют текстового содержимого textContent, их значения хранятся именно в value.

==================================
обработчик событий добавляется не на кнопку, а на саму форму:

let someForm = document.querySelector('.some-form');
someForm.onsubmit = function() {
  console.log('Форма отправлена!');
};

let message = document.querySelector('.subscription-message');

let form = document.querySelector('.subscription');
form.onsubmit = function(evt) {
  // Инструкция ниже отменяет отправку данных
  evt.preventDefault();

};

==================================
Свойство textContent хранит в себе текстовое содержимое элемента.
let paragraph = document.querySelector('p');
console.log(paragraph.textContent);

let message = document.querySelector('.subscription-message');
message.textContent = 'Я новое текстовое содержимое элемента!';

==================================
let page = document.querySelector('.page');
let themeButton = document.querySelector('.theme-button');

themeButton.onclick = function() {
  page.classList.toggle('light-theme');
  page.classList.toggle('dark-theme');
};

==================================
элемент.classList.toggle('класс');

Если класс у элемента есть, метод classList.toggle ведёт себя как classList.remove и класс у элемента убирает.
 А если указанного класса у элемента нет, то
 classList.toggle, как и classList.add,
 добавляет элементу этот класс.

==================================
<body class="page light-theme">

Чтобы выключить светлую тему, убрав класс light-theme у элемента page, используем инструкцию:

document.querySelector('.page').classList.remove('light-theme');

==================================
document.querySelector('селектор');

document — это элемент, внутри которого будет искать JavaScript.
Словом document обозначается веб-страница, к которой подключили скрипт.
Неважно, как называется файл на самом деле, в JavaScript это всегда «документ». Он является элементом-родителем для любого другого элемента на странице.

Метод querySelector ищет по селектору.
==================================
В консоль можно выводить не только текст, но и результаты выполнения инструкций. Например, найденный с помощью querySelector элемент:

console.log(document.querySelector('.page'));
==================================

элемент.classList.remove('класс');

Метод убирает с элемента тот класс, который указан в скобках.
Обратите внимание, что мы не ставим точку перед именем класса в classList.remove.
Это не селектор, JavaScript и так знает, что мы имеем дело с классом.

==================================
Условный оператор „?“
Синтаксис:
let result = условие ? значение1 : значение2;
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
Например:
let accessAllowed = (age > 18) ? true : false;
==================================
Приоритет: ! > && > ||
 !(НЕ)
 result = !value;
Оператор принимает один аргумент и выполняет следующие действия:
    Сначала приводит аргумент к логическому типу true/false.
    Затем возвращает противоположное значение.
В частности, двойное НЕ используют для преобразования значений к логическому типу:
То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его.
alert( !!"non-empty string" ); // true
alert( !!null ); // false

ИЛИ «||» находит первое истинное значение
При выполнении ИЛИ || с несколькими значениями:
Вычисляет операнды слева направо.
Каждый операнд конвертирует в логическое значение.
Если результат true, останавливается и возвращает исходное значение этого операнда.
Если все операнды являются ложными (false), возвращает последний из них.

result = value1 || value2 || value3;


И «&&» находит первое ложное значение
При нескольких подряд операторах И:
Вычисляет операнды слева направо.
Каждый операнд преобразует в логическое значение.
Если результат false, останавливается и возвращает исходное значение этого операнда.
Если все операнды были истинными, возвращается последний.
result = value1 && value2 && value3;
==================================
let accessAllowed = (age > 18) ? true : false;
==================================
Давайте вспомним правила преобразования типов из главы Преобразование типов:

    Число 0,
  пустая строка "",
  null,
  undefined и
  NaN становятся false.

  Из-за этого их называют «ложными» («falsy») значениями.

    Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).
==================================
Чтобы prompt хорошо выглядел в IE, рекомендуется всегда указывать второй параметр:

let test = prompt("Test", ''); // <-- для IE
==================================

Тем не менее, помните, что операции выполняются слева направо.
Если перед строкой идут два числа, то числа будут сложены перед преобразованием в строку:

alert(2 + 2 + '1' ); // будет "41", а не "221"

В то же время
"$" + 4 + 5 = "$45"


==================================
 Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения,
 а undefined – для проверок, была ли переменная назначена.

null для неизвестных значений – отдельный тип, имеющий одно значение null

undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.


==================================
 Обратные кавычки же имеют «расширенный функционал». Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:
let name = "Иван";

// Вставим переменную
alert( `Привет, ${name}!` ); // Привет, Иван!

// Вставим выражение
alert( `результат: ${1 + 2}` ); // результат: 3

================================== ТЕСТЫ
Сделал краткий гайд для начинающих, кто хочет запустить тесты из под Visual Studio Code (VS Code) с помощью отладки.
Для этого понадобится установленный Node.js и VS Code. Фреймворк Mocha будет ставиться локально, т.е. для каждого проекта отдельно (также есть возможность установить его глобально -g).

Команды необходимо прописывать в терминале из под папки с вашим проектом. В моём случае это будет папка D:\Study\javascript\mocha project. В VS Code есть встроенный терминал (вызывается командой ctrl+j), вот его и будем использовать.
1. Заходим в VS Code и открываем папку с проектом "mocha project". Первое, что необходимо сделать перед началом — это инициализировать наш проект, чтобы создать файл package.json, где будут храниться все настройки нашего проекта. В терминале прописываем команду:

npm init -y


Флаг -y пропускает все вопросы. Если же возникнет ошибка, то необходимо убрать пробелы из названия папки проекта, либо же запустить команду без флага -y и ответить на вопросы.
2. Теперь перейдем к установке Mocha и Chai. Ставить будем с флагом --save-dev — этот флаг прописывает в packeg.json зависимости, которые нужны будут, только при разработке проекта. Прописываем следующие команды:

npm install mocha --save-dev
npm install chai --save-dev


После установки можно открыть файл launch.json в папке с проектом и убедиться, что зависимости прописаны в "devDependencies".
3. Дальше необходимо добавить новую конфигурацию для запуска отладки в VS Code. Открываем окно с отладкой (Ctrl+Shift+D) и выбираем из выпадающего меню (рядом с зеленой стрелкой пуска отладки) пункт Add Configuration (Добавить конфигурацию). Дальше можно выбрать любой из доступных Node.js/Chrome, откроется файл launch.json (если не открылся, то нажмите на шестеренку) с настройками в папке .vscode, которая создастся в корне вашего проекта. Справа внизу будет гореть кнопка Add Configuration. Жмем её и выбираем из предложенных вариантов Node js: Mocha Tests. Добавятся настройки для этого пресета, рассмотрим важные настройки более подробно:
— По умолчанию стоит тип тестирования "tdd", меняем его на "bdd"
— Путь для запуска тестов по дефолту указан: "${workspaceFolder}/test", но можно и изменить на тот, что вам больше нравится, т.е. в эту папку необходимо помещать файлы тестов.
4. Покончили с настройкой среды для запуска тестов, осталось подготовить файлы. Создаем app.js в корне проекта и прописываем там код, который будем тестировать:

function pow(x, n) {
//... код функции
}
// прописываем название функции для экспорта, чтобы мы смогли вызвать её в файле с тестами (через запятую можно указать несколько функций)
module.exports = {
pow
};


5. Создаем файл с тестами. Для того, чтобы всё сработало, необходимо подключить библиотеку Chai внутри нашего теста + файл, код которого будет тестироваться. Для доступа к нашей функции pow необходимо обратиться через точку к методу объекта test: test.pow(x, n). Создаем в папке test файл для тестирования, у меня он будет называться 123.js:

const chai = require('chai');  // подключаем библиотеку Chai
const assert = chai.assert;    // присваиваем переменной assert функции из библиотеки Chai
const test = require('../app'); // подключаем файл для тестирования (app - это название файла app.js). В переменной test будет храниться объект с теми функциями, которые мы указали при экспорте.
describe("pow", function() {
  //... код тестов
  it('3 в степени 3 будет 27', function() {
  assert.equal(test.pow(3, 3), 27);
  });
});


6. Запускаем отладку и радуемся результату.
Надеюсь кому-нибудь смог помочь, писал больше для себя, чтобы разобраться. Тема с тестами и правда очень рано затрагивается и без знаний ее сложно переварить.
