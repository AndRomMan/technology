Критерии.
Курс JS1.  Профессиональная разработка веб-интерфейсов

======================================= Базовые =======================================

======================================= Задача
Б1. Код соответствует техническому заданию проекта.
Все обязательные пункты технического задания выполнены.

==================
Б2. При выполнении кода не возникает необработанных ошибок.
При открытии диалогов, загрузки данных и работе с сайтом не возникает ошибок,
программа не ломается и не зависает.

======================================= Именование
Б3. Названия переменных, параметров, свойств и методов начинаются со строчной буквы
и записываются в нотации lowerCamelCase.

==================
Б4. Для названия значений используются английские существительные.
Сокращения в словах запрещены.
Сокращённые названия переменных можно использовать только,
если такое название широко распространено.

    Допустимые сокращения:
    - xhr, для объектов XMLHttpRequest;
    - evt для объектов Event и его производных (MouseEvent, KeyboardEvent и подобные);
    - ctx для контекста канваса;
    - i, j, k, l, t для счётчика в цикле, j для счётчика во вложенном цикле и так далее по алфавиту;
      если циклов два и более, то можно не переиспользовать переменную i;
    - cb для единственного коллбэка в параметрах функции;
    - img для именования переменной, содержащей ссылку на тег <img>;
    - src для именования переменной, хранящей адрес, например изображения;
    - err для обозначения объекта ошибок в конструкциях try...catch или коллбэках.

Допустимо именовать переменные-предикаты — флаги или функции
которые возвращают булево значение — по схеме «is + признак».
    Например:
var loading = true; // правильно
var isLoading = true; // тоже правильно

function checkValueToNull(value) { // правильно 
  return value === null;
}

function isNull(value) { // тоже правильно
  return value === null;
}

==================
Б5. Массивы названы существительными во множественном числе.
    Правильно:
var ages = [12, 40, 22, 7];
var names = ['Иван', 'Петр', 'Мария', 'Алексей'];

var wizard = {
  name: 'Гендальф',
  friends: ['Саурон', 'Фродо', 'Бильбо']
};

Обратите внимание, что слово data — это множественное число от слова datum,
поэтому его использование в качестве имени переменной для массива корректно.

==================
Б6. Название функции или метода содержит глагол.
Название функции или метода должно быть глаголом и соответствовать действию,
которое выполняет функция или метод.
Например, можно использовать глагол get для функций и методов, которые что-то возвращают.

Исключения:
    Функции конструкторы (см. критерий Конструкторы названы английскими существительными).
    Функции обработчики или коллбэки (см. критерий Из названия обработчика события и функции-коллбэка следует, что это обработчик).

    Правильно:
    var printNames = function (names) {
      names.forEach(function (name) {
        console.log(name);
      });
    };
    var wizard = {
      name: 'Гендальф',
      fire: function () {
        console.log('Стреляю файрболлом!');
      }
    };
    var getRandomNumber = function () {
      return Math.random();
    };

==================
Б7. Названия констант (постоянных значений) написаны прописными (заглавными) буквами.
Слова разделяются подчёркиваниями (UPPER_SNAKE_CASE), например:

var MAX_HEIGHT = 400;
var EARTH_RADIUS = 6370;

==================
Б8. Название конструкторов и перечислений начинается с заглавной буквы.
В названии используются английские существительные.
Значения перечислений объявлены как константы.

    Правильно:
    // Функция-конструктор
    var Wizard = function (name, age) {
      this.name = name;
      this.age = age;
    };

    // Функция
    var fly = function (coordinate) {
      console.log('Смотрите я лечу!');
    };

    // Перечисление
    var StatusCode = {
      OK: 200,
      NOT_FOUND: 404,
      BAD_REQUEST: 400,
    };

Названия функций, не являющихся конструкторами, должны начинаться со строчной буквы.

Обратите внимание, что не все объекты в коде проекта должны быть перечислениями.
Например, допускается использование объектов в качестве словарей:
var priceTypeToRange = {
  low: 'до 200 ₽',
  medium: 'от 200 ₽ до 500 ₽',
  high: 'от 500 ₽',
};

======================================= Форматирование и внешний вид
Б9. Используются обязательные блоки кода.

В любых конструкциях, где подразумевается использование блока кода (фигурных скобок),
таких как for, while, if, switch, function — блок кода используется обязательно,
даже если инструкция состоит из одной строчки.

Правильно:
var isEven = true;
if (x % 2 === 1) {
  isEven = false;
}

==================
Б10. Список констант идёт перед основным кодом.
Все константы выносятся в начало модуля.

==================
Б11. Код соответствует стилю оформления, принятому на проекте (ESLint).
    Отступы между операторами и ключевым словами соответствуют стилю оформления, принятому на проекте;
    Для отступов используются одинаковые символы, вложенность кода обозначается отступами;
    Однообразно расставлены пробелы перед, после и внутри скобок, операторов и ключевых слов.

==================
Б12. В итоговом коде проекта находятся только те файлы,
которые были на момент создания репозитория,
которые были получены в патчах и файлы, созданные по заданию.

======================================= Мусор
Б13. В коде проекта нет файлов, модулей и частей кода, которые не используются,
включая закомментированные участки кода.

==================
Б14. В коде нет заранее недостижимых участков кода.

    Например:
        Невыполнимые условия:
    var happen = false;
    if (happen) {
      console.log('This will not happen anyway!');
    }

        Операции после выхода из функции:
    (function () {
      return;
      console.log('This will not happen!');
    })();


======================================= Корректность
Б15. Константы нигде в коде не переопределяются.
Константы используются только для чтения,
и никогда не переопределяются на всем промежутке жизни программы.

==================
Б16. Включён строгий режим (ESLint).
В коде запрещены небезопасные конструкции.
Код работает в строгом режиме.
В начале js-файлов установлена директива 'use strict';.

==================
Б17. Используются строгие сравнения вместо нестрогих (ESLint).
Вместо операторов нестрогого сравнения == и !=,
используются операторы строгого сравнения ===, !==.
http://dorey.github.io/JavaScript-Equality-Table/

    Правильно:

    var foo = '';
    var bar = [];
    if (foo === bar) {
      destroy(world);
    }

==================
Б18. В коде не используются зарезервированные слова
в качестве имён переменных и свойств.

В названия переменных и свойств не включаются операторы
и ключевые слова зарезервированные для будущих версий языка
(например, class, extends).
Список всех зарезервированных слов:
 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords

======================================= Модульность
Б19. Все скрипты подключаются через файл index.html.
Файлы скриптов подключаются перед закрывающимся тегом </body>,
атрибуты async и defer не используются.

==================
Б20. Все файлы JS представляют собой отдельные модули в IIFE.
Экспорт значений производится через глобальную область видимости.
Код вне модуля запрещён.
Вне модуля могут располагаться комментарии и утилитные инструкции, такие как 'use strict';.

Модуль — это законченный фрагмент кода.
То есть фрагмент, который выполняет одну конкретную задачу.
Например, загрузку данных или отрисовку шаблона.

======================================= Универсальность
Б21. Код является кроссбраузерным и не вызывает ошибок в разных браузерах и разных операционных системах.

При проверке этого критерия, необходимо удостовериться в правильной работе и отсутствии сообщений об ошибках в выполняемых скриптах только в последних версиях браузеров: Chrome, Firefox, Safari, Microsoft Edge (и на движке EdgeHTML, и на движке Blink).

Обратите внимание, Safari плохо поддерживает работу с валидацией. Например, не показывает ошибку, если при отправке формы не введены данные в поле с атрибутом required. Поэтому небольшие ошибки, связанные с валидацией только в Safari, можно проигнорировать.

Важно: на Windows тестировать в Safari не нужно,
на Linux также не нужно тестировать в Edge на движке EdgeHTML,
поскольку этих браузеров в данных ОС нет.

======================================= Магия
Б22. Нельзя пользоваться глобальной переменной event.

Приводит к неосознанному коду:
var elem = document.querySelector('.test');
var onElemClick = function () {
  event.target.innerText = 'you really need event';
};
elem.addEventListener('click', onElemClick);

======================================= Оптимальность
Б23. Своевременный выход из цикла: цикл не работает дольше чем нужно.
    Неправильно:
    apartments.forEach(function (it, index) {
      if (index < 3) {
        render(it);
      }
    });

    Правильно:
    for (var i = 0; i < Math.min(apartments.length, 3); i++) {
      render(apartments[i]);
    }

==================
Б24. Количество вызовов циклов минимизировано.
Если задачу можно решить за один проход по циклу,
вместо нескольких она должна быть решена за один.

    Неправильно:
    var wizardNames = source.map(function (it) {
      return it.wizard;
    }).map(function (it) {
      return it.name;
    });

    Правильно:
    var wizardNames = source.map(function (it) {
      return it.wizard.name;
    });

==================
Б25. Множественные DOM-операции должны производятся на элементах, которые не добавлены в DOM.
Например, наполнение скопированного из шаблона элемента данными
или генерация разметки целиком средствами JavaScript:

    var cardList = document.querySelector('.card-list');
    var cardTemplate = document.querySelector('#card-template').content;
    var card = cardTemplate.cloneNode(true);
    var message = document.createElement('p');

    card.querySelector('.title').textContent = 'Hello, world!';
    message.textContent = 'How are you?';

    card.querySelector('.message').appendChild(message);
    cardList.appendChild(card);

======================================= Безопасность
Б26. Обработчики событий добавляются и удаляются своевременно.
Обработчики событий для виджетов добавляются только в момент появления виджета
на странице и удаляются в момент их исчезновения.

Защита от memory-leak
Количество обработчиков, подвешенных на глобальную область видимости, не должно возрастать.
Например, если подвешивается обработчик, который следит за перемещением курсора по экрану,
то он должен подвешиваться и отвешиваться в нужный момент.
Случай, когда обработчик на document только подвешивается,
может свидетельствовать о проблеме бесконечного создания обработчиков и потенциальной утечке памяти.

Защита от неправильного поведения интерфейса
Например, на странице может существовать popup, который скрывается по ESC.
Лучше для него гасить обработчик, если он не показан, потому что он может каким-то образом
ломать поведение сайта — останавливать распространение, отменять поведение по умолчанию и так далее.
Поэтому поведение должно быть явным —
если в этот момент времени обработчики не нужны, их нужно удалить. Явное и предсказуемое поведение.

==================
Б27. Для вставки пользовательских строк (имён, фамилий и так далее) использован textContent.
Защита от XSS-атак, а также изменения исходных данных, запутывание пользователя и прочее.

Неправильно: через innerHTML вставляются данные, которые невозможно полностью контролировать.
Это может быть пользовательский ввод, который может содержать XSS.

var listItem = listItemTemplate.cloneNode(true);
listItem.querySelector('.title').innerHTML = user.fullName;

Правильно: через innerHTML вставляется код, который был создан программистом,
поэтому сделать его вредоносным невозможно.
innerHTML используется для лаконичного создания сложной разметки,
но при этом в разметку не вставляются никакие внешние данные.

var listItemTemplate = '<li class="amenity"><i></i><a href="#"></a></li>';
list.innerHTML = listItemTemplate;


======================================= Дополнительные =======================================

======================================= Именование
Д3. Название методов и свойств объектов не содержит название объектов.
    Неправильно:
    popup.openPopup = function () {
      console.log('I will open popup');
    };
    wizard.wizardName = 'Пендальф';

    Правильно
    popup.open = function () {
      console.log('I will open popup');
    };
    wizard.name = 'Пендальф';

==================
Д4. Из названия обработчика события и функции-коллбэка следует, что это обработчик.
Для единственного обработчика или функции можно использовать callback или cb.
Для именования нескольких обработчиков внутри одного модуля используется
on или handler и описание события.
 Название обработчика строится следующим образом:
        on + (на каком элементе) + что случилось:
        var onSidebarClick;
        var onContentLoad;
        var onResize;

            (на каком элементе) + что случилось + Handler:
        var sidebarClickHandler;
        var contentLoadHandler;
        var resizeHandler;


======================================= Единообразие
Д5. Все функции объявлены единообразно.
Все функции создаются в едином стиле:
используется либо «функциональное выражение»,
либо как «функциональное объявление».
Смешение стилей в рамках проекта не допускается.

    Неправильно:
    var doSomethingElse = function () {
      // function body
    };

    function doSomething() {
      // function body
    }

    Правильно:

    var doSomething = function () {
      // function body
    };

    var doSomethingElse = function () {
      // function body
    };

    или

    function doSomething() {
      // function body
    }

    function doSomethingElse() {
      // function body
    }

==================
Д6. Используется единый стиль именования переменных.
Стиль именования переменных сохраняется во всех модулях, например:
    не следует мешать обработчики содержащие Handler и on;
    если переменные, которые хранят DOM-элемент и содержат слово Element, то это правило работает везде.

    Неправильно:
    var popupMainElement = document.querySelector('.popup');
    var sidebarNode = document.querySelector('.sidebar');
    var similarContainer = popupMainElement.querySelector('ul.similar');

    Правильно:
    var popupMainElement = document.querySelector('.popup');
    var sidebarElement = document.querySelector('.sidebar');
    var similarContainerElement = popupMainElement.querySelector('ul.similar');


==================
Д7. При использовании встроенного API, который поддерживает несколько вариантов использования,
используется один способ.
Если существуют несколько разных API, позволяющих решить одну и ту же задачу,
например, поиск элемента по id в DOM-дереве, то в проекте используется только один из этих API.

    Неправильно:
    var popupMainElement = document.querySelector('#popup');
    var sidebarElement = document.getElementById('sidebar');

    var popupClassName = popupMainElement.getAttribute('class');
    var sidebarClassName = sidebarElement.className;

    Правильно:
    var popupMainElement = document.querySelector('#popup');
    var sidebarElement = document.querySelector('#sidebar');

    var popupClassName = popupMainElement.getAttribute('class');
    var sidebarClassName = sidebarElement.getAttribute('class');
    или
    var popupMainElement = document.getElementById('popup');
    var sidebarElement = document.getElementById('sidebar');

    var popupClassName = popupMainElement.className;
    var sidebarClassName = sidebarElement.className;

======================================= Корректность
Д8. API встроенных функций и объектов используется правильно.
Передаются корректные значения, которые ожидаются по спецификации.

Неправильно:
    var isPressed = element.getAttribute('aria-pressed', false);
Правильно:
    var isPressed = element.getAttribute('aria-pressed');


    Встроенные методы массивов используются по назначению.
    Неправильно:
    var greet = 'Привет ';
    wizards.map(function (it) {
      greet += ', ' + it.name;
    });
    console.log(greet + '!');

    Правильно:
    var greet = 'Привет ';

    var names = wizards.map(function (it) {
      return it.name;
    });
    console.log(greet + names.join(', ') + '!');

==================
Д9. Отсутствуют потенциально некорректные операции.
Например, некорректное сложение двух операндов как строк.
 Проблема приоритета конкатенации над сложением.

    Неправильно:
    new Date() + 1000;

    Правильно:
    +new Date() + 1000;

Некорректные проверки на существование с числами.
Пример некорректной проверки на то, что переменная является числом:
    var double = function (value) {
      if (!value) {
        return NaN;
      }
      return value * 2;
    };

    double(0);
    double();
    double(5);

======================================= Модульность
Д10. В случае, если одинаковый код повторяется в нескольких модулях,
повторяющаяся часть вынесена в отдельный модуль.

Критерий касается структурных единиц кода — повторяющийся блок кода,
либо функции с одним и теми же конструкциями, например, утилитные методы для проверки клавиш:

// Файл keyboard.js
'use strict';

(function () {
  var ENTER_KEYCODE = 13;
  var ESC_KEYCODE = 27;

  window.keyboard = {
    isKeyBoardEvent: function (evt) {
      return evt instanceof KeyboardEvent;
    },
    isEnterPressed: function (evt) {
      return evt.keyCode === ENTER_KEYCODE;
    },
    isEscPressed: function (evt) {
      return evt.keyCode === ESC_KEYCODE;
    }
  };
})();

Не стоит выносить в отдельный модуль одну повторяющуюся инструкцию:
// Файл hide-gallery.js
'use strict';

(function () {
  window.hideGallery = function (gallery) {
    return gallery.classList.add('invisible');
  };
})();

==================
Д11. При экспорте из одного модуля нескольких значений используется пространство имён.
Множественные значения записываются в один объект. Имя объекта совпадает с именем файла без учёта кейса.

    Неправильно:
    // Файл dialog-util.js
    'use strict';

    (function () {
      var ENTER_KEYCODE = 13;
      var ESC_KEYCODE = 27;

      window.isEnterPressed = function (evt) {
        return evt.keyCode === ENTER_KEYCODE;
      };

      window.isEscPressed = function (evt) {
        return evt.keyCode === ESC_KEYCODE;
      };
    })();

    Неправильно:
    window.card = {open: function () {}};

    Правильно:
    // Файл dialog-util.js
    'use strict';

    (function () {
      var ENTER_KEYCODE = 13;
      var ESC_KEYCODE = 27;

      window.dialogUtil = {
        isEnterPressed: function (evt) {
          return evt.keyCode === ENTER_KEYCODE;
        },
        isEscPressed: function (evt) {
          return evt.keyCode === ESC_KEYCODE;
        }
      };
    })();

==================
Д12. Во всех модулях для ограничения области видимости используются IIFE и только они.
    Правильно:
    'use strict';

    (function () {
      window.load = function (url, onLoad) {
        var xhr = new XMLHttpRequest();
        xhr.addEventListener('load', onLoad);

        xhr.responseType = 'json';
        xhr.open('GET', url);
        xhr.send();
      };
    })();

======================================= Избыточность
Д13. В проекте не должно быть избыточных проверок.
Например, если заранее известно, что функция всегда принимает числовой параметр,
то не следует проверять его на существование.

    Неправильно:
    var isPositiveNumber = function (myNumber) {
      if (typeof myNumber === 'undefined') {
        throw new Error('Parameter is not defined');
      }
      return myNumber > 0;
    };

    isPositiveNumber(15);
    isPositiveNumber(-30);

    Правильно:
    var isPositiveNumber = function (myNumber) {
      return myNumber > 0;
    };

    isPositiveNumber(15);
    isPositiveNumber(-30);

==================
Д14. Отсутствует дублирование кода: повторяющиеся части кода переписаны как функции.
При написании кода следует придерживаться принципа DRY.

==================
Д15. Если при использовании условного оператора в любом случае возвращается значение, альтернативная ветка опускается.

    Неправильно:
    var decide = function (val, anotherVal) {
      if (2 > 1) {
        return val;
      } else {
        return anotherVal;
      }
    };

    Правильно:
    var decide = function (val, anotherVal) {
      if (2 > 1) {
        return val;
      }

      return anotherVal;
    };

==================
Д16. Отсутствуют лишние приведения и проверки типов.
Если заранее известно, что в переменной число,
то нет смысла превращать переменную в число parseInt(myNumber).
Тоже касается и избыточной проверки булевой переменной.

    Неправильно:
    if (booleanValue === true) {
      console.log('It\'s true!');
    }

    Правильно:
    if (booleanValue) {
      console.log('It\'s true!');
    }

==================
Д17. Там, где возможно, в присвоении значения вместо if используется тернарный оператор.

    Неправильно:
    var sex;
    if (male) {
      sex = 'Мужчина';
    } else {
      sex = 'Женщина';
    }

    Правильно:
    var sex = male ? 'Мужчина' : 'Женщина';

==================
Д18. Условия упрощены.

Если функция возвращает булево значение, не используется if..else с лишними return.
    Неправильно:
    var equals = function (firstValue, secondValue) {
      if (firstValue === secondValue) {
        return true;
      } else {
        return false;
      }
    };

    Правильно:
    var equals = function (firstValue, secondValue) {
      return firstValue === secondValue;
    };

================== Магия
Д19. В коде не используются «магические значения»,
под каждое из них заведена отдельная переменная, названная как константа.

======================================= Оптимальность
Д20. Константы, используемые внутри функций, создаются вне функций
и используются повторно через замыкания.

==================
Д21. Поиск элементов по селекторам делается минимальное количество раз,
после этого ссылки на элементы сохраняются.

==================
Д22. Массивы и объекты, содержимое которых вычисляется, собираются один раз,
а после этого только переиспользуются.

==================
Д23. Изменения применяются точечно.

Например, при удалении классов с DOM-элемента, не производится попытка удалить
все возможные классы, если можно убрать лишь тот,
который действительно установлен на DOM-элементе в данный момент.

======================================= Сложность. Читаемость.
Д24. Для каждого события используется отдельный обработчик.

Одна функция не является обработчиком нескольких разных событий.

    Неправильно:
    var KEY_CODE_ENTER = 13;

    var activationHandler = function (evt) {
      if (evt.keyCode === KEY_CODE_ENTER || evt.type === 'click') {
        showPopup();
      }
    };

    button.addEventListener('click', activationHandler);
    button.addEventListener('keydown', activationHandler);

    Правильно:
    var KEY_CODE_ENTER = 13;

    var buttonClickHandler = function () {
      showPopup();
    };

    var buttonKeydownHandler = function (evt) {
      if (evt.keyCode === KEY_CODE_ENTER) {
        showPopup();
      }
    };

    button.addEventListener('click', buttonClickHandler);
    button.addEventListener('keydown', buttonKeydownHandler);

==================
Д25. Длинные функции и методы разбиты на несколько небольших.

==================
Д26. Для работы с JS-коллекциями используются итераторы для массивов.

Итераторы используются для трансформаций массивов
— map, filter, sort и прочие.
А также для обхода проблемы потери окружения в циклах — forEach.

    Например:
    elements.forEach(function (el) {
      el.onclick = function () {
        console.log(el);
      };
    })

==================
Д27. Оператор присваивания не используется как часть выражения.

    Неправильно:
    imgGenerate(picArray = JSON.parse(data));

    Правильно:
    picArray = JSON.parse(data);
    imgGenerate(picArray);

=======================================

==================

==================
