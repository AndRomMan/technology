/* eslint-disable no-alert */
/* eslint-disable no-console*/
'use strict';

// В этом примере поле name приходит аргументом в функцию создания объекта.
// А через this мы можем получить к нему доступ в методе greet
//  в любой момент времени

let createWizard = function(name) {
  let wizard = {
    name: name,
    greet: function () {
      console.log('Привет! Меня зовут: ' + this.name);
    }
  };

  return wizard;
};

let wizard1 = createWizard('Пендальф');
let wizard2 = createWizard('Саруман');

// wizard1.greet();
// wizard2.greet();

function anyFunction(cb) {
  cb();
}

// Но в работе с контекстом в JS есть особенности.
// Если передать метод объекта в качестве колбека в другую функцию,
// то возникает потеря контекста и this начинает ссылаться на глобальный контекст.
// Это может быть window или undefined в случае строгого режима.

// anyFunction(wizard1.greet);
// anyFunction(wizard2.greet);

// Это происходит из-за того, что контекст вычисляется в момент вызова функции.
// И в случае вызова функции как метода,
// вычисление происходит по правилу <контекст.>greet().
// А в случае вызова функции как колбека,
// у нас нет этого контекста <как_будто_тут_undefined.>callback().

// Но это легко лечится с помощью метода bind,
// который есть у каждой функции (да, функция тоже объект).
// Алгоритм использования bind простой.
// То что слева от bind, то должно быть и справа.
// <контекст.>greet.bind(контекст)

anyFunction(wizard1.greet.bind(wizard1));
anyFunction(wizard2.greet.bind(wizard2));

// ===========================================================
// Метод bind привязывает контекст к функции.
// В качестве первого параметра следует передавать контекст,
// а последующими параметрами - параметры функции.
// Метод возвращает новую функцию,
// внутри которой this будет равным переданному контексту.
// функция.bind(контекст, параметр1, параметр2...);

let elem = document.querySelector('#text');
console.log(elem);

function func(param1, param2) {
	console.log(this.value + ': ' + param1 + ', ' + param2);
}

// С помощью bind сделаем новую функцию, которая будет копией функции func,
// но this в ней всегда будет равен elem:
console.log('__________ bind function');
let newFunc = func.bind(elem);

//  Теперь в переменной newFunc лежит функция.
//  Давайте вызовем ее, передав в первый параметр '1', а во второй '2':
newFunc('1', '2');

//  Не обязательно записывать результат работы bind в новую функцию newFunc,
//  можно просто перезаписать func:
func = func.bind(elem);
